{"meta":{"title":"某熊猫桑·自留地","subtitle":null,"description":null,"author":"某熊猫桑","url":"https://marsgt.github.io","root":"/"},"pages":[{"title":"","date":"2019-01-25T14:32:12.200Z","updated":"2019-01-25T14:32:12.200Z","comments":false,"path":"categories/index.html","permalink":"https://marsgt.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2019-01-25T14:32:19.787Z","updated":"2019-01-25T14:32:19.787Z","comments":false,"path":"tags/index.html","permalink":"https://marsgt.github.io/tags/index.html","excerpt":"","text":""},{"title":"技术收藏夹","date":"2019-03-08T01:45:04.502Z","updated":"2019-03-08T01:45:04.502Z","comments":false,"path":"nav/index.html","permalink":"https://marsgt.github.io/nav/index.html","excerpt":"","text":"整理收藏夹里一些工作中会用到的网站。 在线文档 综合类文档平台 印记中文 腾讯云 - 开发者手册 极客学院 - Wiki DevDocs API Documentation GitHub最全的前端资源汇总仓库 前端资源总览 Linux开发教程 - CTOLib 码库 云平台 阿里云 - 帮助文档 腾讯云 - 文档平台 新浪云 - 支持中心 京东云 - 帮助中心 Azure(中国区) - 文档 语言类文档 Lua Lua - Documentation Lua5.3 参考手册（菜鸟教程） W3School Lua 教程 Lua 全教程 JavaScript &amp; Web API Web 开发技术 - MDN Web API 接口参考 - MDN 事件参考 - MDN JavaScript 教程 - 阮一峰 Web API 教程 ECMAScript 6 入门 - 阮一峰 ECMAScript 5.1 中文版 - 颜海镜 现代 Javascript 教程 Internet Explorer compatibility cookbook (Internet Explorer 兼容性手册)) You Don’t Know JS (中文版) JavaScript 算法与数据结构 (中文版) 冴羽的博客 - 包含 JavaScript 深入系列、JavaScript 专题系列、Underscore 系列 《深入理解ES6》教程学习笔记 Airbnb JavaScript 编码规范（翻译版） TypeScript TypeScript 中文网 - 文档 TypeScript Handbook（中文版） 深入理解 TypeScript CSS CSS 参考 - MDN CSS 参考手册 CSS 教程手册（新） 缓动函数速查表 Stylus Stylus 中文文档 - 张鑫旭 HTML HTML 元素参考 - MDN HTML 元素全局属性 - MDN HTML head 头标签 - FEX HEAD 标签大全 SVG SVG - MDN SVG - Windows Emmet Emmet Documentation PHP PHP 官方文档 - 语言参考 PHP 官方文档 - 函数参考 PHP 官方文档 - 上下文（Context）选项和参数 PHP 最佳实践（译）：一份简短的关于 PHP 容易混淆知识点的实用指南 PHP 之道 Markdown MarkDown - 语法说明 GitHub 风格的 Markdown 语法（译） Markdown 编辑器语法指南 其它 Kotlin 参考文档 Rust 编程语言 - Rust 中文社区 YAML 语言教程 - 阮一峰 TOML： GitHub 这是要革 YAML 的命呀！ PlantUML 现代 Web 开发基础与工程实践 - 王下邀月熊 How to be a Programmer 中文版 互联网 Java 工程师进阶知识完全扫盲 长期维护更新，前端面试题 移动端 触摸事件 - MDN 腾讯移动 Web 前端知识库 这里收集了许多移动端上遇到的各种坑 - 司徒正美 浏览器内核（移动端） 腾讯浏览服务(TBS/X5) X5 Caniuse WebKit JS - Apple Developer Documentation Safari Extensions JS - Apple Developer Documentation 开发者中心 - UC 优视 腾讯系文档 微信公众平台技术文档 微信公众平台小程序开发文档 微信 JS-SDK 说明文档 - 微信公众平台 全局返回码说明 - 微信公众平台 微信支付开发文档 微信广告帮助中心 微信 JS-SDK 说明文档 - 微信企业号开发者中心 开发资源 - 微信开放平台 微信硬件平台 腾讯移动 Web 开发平台 TGideas 文档库（腾讯游戏） 阿里系文档 阿里巴巴集团开源软件巡礼 天猫品牌营销服务 Tida JSSDK 文档(老版) - 蚂蚁金服 凤蝶 - 移动建站平台 HTTP 及网页服务器 HTTP 状态码 HTTP/3 详解 Nginx Nginx中文文档 - CTOLib 码库 Nginx中文文档 - Tengine OpenResty OpenResty最佳实践 - CTOLib 码库 ServerLess Serverless Framework Documentation Serverless 架构应用开发指南 - phodal 运维相关（临时） Linux 命令大全(查询) Linux 命令大全 - CTOLib 码库 Linux 软件速查表 - CTOLib 码库 系统管理员资源速查表 - CTOLib 码库 php.ini 中文版 - 金步国 Apache HTTP Server 版本2.2 - 金步国 开发工具 Documentation - Visual Studio Code Visual Studio Code 中文手册 VS Code 插件开发文档 - 中文版 JavaScript Programming with Visual Studio Code jsconfig.json 范例 为 JavaScript IntelliSense 创建 JSDoc 注释 所需即所获：像 IDE 一样使用 vim Vim 从入门到精通 Chrome 开发者工具中文文档 版本管理（Git） Git Community Book 中文版 沉浸式学 Git Git 常用命令速查表（图片） Git 权威指南 Git 飞行规则 (Flight Rules) 猴子都能懂的 GIT 入门 Awesome（资源汇总） awesome（综合性汇总） Lists（比较杂的综合性汇总） Awesome Awesomeness（语言和杂项的综合性汇总） Awesome-MaterialDesign（偏重 Material Design 设计资源的汇总） D2 前端资源库 前端资源总览 轮子 CMS StaticGen: 静态页面生成器汇总 headlessCMS：无头/纯静态 CMS 汇总 Let’s talk JS: 文档生成器汇总 GatsbyJS：React+GraphQL 的网站生成系统 Hugo：Go语言实现的静态网站生成器 Hexo Hexo NexT 使用文档 Gitalk：基于 Github Issue 的现代评论组件 MkDocs：Markdown文档生成 Publii：开源的静态站点 CMS prime: 开源的 GraphQL CMS 纸壳CMS：开源免费可视化设计内容管理系统 docsify：生成在线文档 jQ系 Zepto Zepto.js (Github) Motion.js（鹅厂基于ZeptoJS的组件库） Motion.js 打包下载页面 插件 zepto.fullpage（zepto全页滚动插件） zepto.fullpage源码注释理解 | Lyu Dada jQuery jQuery (Github) 原生与 jQuery代码互转参考（英文） jQuery 构建页（英文） jQuery UI 构建下载（英文） JQuery EasyUI 中文网 jQuery WeUI（jQ 微信 UI 库） 插件 jquery.guide.js：操作向导镂空提示插件（by 张鑫旭） jQ 旋转插件 jQ 旋钮插件 jQ 线图插件 jQ 二维码插件 jQ 面部识别插件 jQ 分享插件 JSLite 文档 TypeScript TypeSearch: 搜索 Types 包 DefinitelyTyped: 优质 Types 库 CSS 预处理/后处理 PostCSS PostCSS PostCSS Plugins PostCSS.parts PreCSS SASS SASS SASS 中文文档 SASS 缓动函数插件 布局及通用 UI 框架 BootStrap 系 BootStrap 中文网 Bootstrap v3 全局 CSS 样式 Pingendo - Free Bootstrap 4 builder Start Bootstrap：免费Bootstrap主题及模板 Bootswatch：Bootstrap免费模板站 Propeller：基于 Bootstrap 与 Material Design 的 UI 框架 gentelella: 免费Bootstrap 3后台管理模板 AdminLTE 2 | Dashboard AdminLTE (Github) AdminLTE 的使用 SUI：基于 Bootstrap 开发+设计规范 ZUI：基于 Bootstrap 的前端跨屏框架 图标库及字体 草莓图标库 Font Awesome 中文网 – | 字体图标 Iconfont-阿里巴巴矢量图标库 IceMoon APP fonts.css: 跨平台 CSS 中文字体解决方案 ZanUI: 有赞组件库 LayUI: 模块化前端 UI 框架 Pure.CSS: 超小 CSS 框架 Amaze UI: 跨屏前端框架 QMUI: 腾讯广研 UI 项目 DxyUI: 丁香园 UI 项目 YDUI: 移动端&amp;微信 UI 基于 FlexBox 的栅格化布局库 butterCake：基于Flexbox的开源CSS框架 NEC: 更好的CSS样式解决方案 MUI: 接近原生体验的 UI 框架 AUI: 移动前端 UI 库 WeUI.js: 腾讯 WeUI 的 JS 版本 LuLu UI: 阅文前端 UI 框架 袋鼠 UI: 美团 UI 框架 wired-elements: 草图风格的 UI 组件 Spectre.css：轻量级、自适应的现代 CSS 框架 Wijmo 前端开发组件: 新一代JavaScript控件集 （更新至 2019-3-5，未完待续…）"}],"posts":[{"title":"使用Phaser3编写H5的简易避坑指南","slug":"使用Phaser3编写H5的简易避坑指南","date":"2019-09-15T08:08:12.000Z","updated":"2019-09-15T08:46:27.728Z","comments":true,"path":"2019/09/15/使用Phaser3编写H5的简易避坑指南/","link":"","permalink":"https://marsgt.github.io/2019/09/15/使用Phaser3编写H5的简易避坑指南/","excerpt":"回到H5行业后的前几个项目，试着用了下以前一直想用的Phaser3，体验还阔以。本篇简单讲讲一些经验和碰到过的坑。","text":"回到H5行业后的前几个项目，试着用了下以前一直想用的Phaser3，体验还阔以。本篇简单讲讲一些经验和碰到过的坑。 首先需要提前讲的，比较合适的参考/文档(目前来看)有以下三个： Phaser3 官方 API 文档 Phaser3 官方 Demo 集锦 (我心目中巨实用的)目前最靠谱的第三方文档 （最后一个重点推荐，之前有好多东西，我看官方文档看的满头问号，但是看这个文档是真的能看懂~） 好，下面可以开始(suì)正(suì)题(niàn)了。 Phaser3使用起来大概可以分成 3 个部分： 加载基础的库文件(废话)，这里包括Phaser3库本体(可以自己定制)和一些第三方插件(如果有的话)； 全局配置，是一个对象，包括渲染方式(Canvas 还是 WebGL)、背景色、Canvas 容器的 CSS 基础样式、缩放适配、事件监听的开/闭，一直到 Scene 配置(后边讲)，直接写到里边就成； Scene，简单来说有点像游戏里的场景，每个场景里会包含各自独立的精灵、图片之类不同的资源，以及各种数据，甚至插件等。比如切换页面，就可以直接用场景功能来实现。 在代码结构上，我个人比较倾向于每个Scene/页面一个文件，一个Scene重新new个Phaser.Scene出来就好。然后在首页HTML里把每个Scene文件全加载以后，再上init.js全局配置就行了。当然，一些统计/jQ辅助/wechat分享注册/bgm自动加载之类的代码放前边就好。 下边说一些零零碎碎的经验： 首先是Phaser3库文件可以精简，官方有个photonstorm/phaser3-custom-build项目，就是教你怎么自己build库文件的，我自己fork了一下放到了MarsGT/phaser3-custom-build，主要是敲掉一些用不着的东西，精简过后大概600k~800k左右。 this.add.text如果用自定义字体（比如用Fontmin精简过的），需要在HTML里加个用了这个字体的div，比如&lt;div style=&#39;font-family:myfont;position:absolute;visibility:hidden;&#39;&gt;000&lt;/div&gt;，否则字体不会生效；如果就想用默认的字体，直接把fontFamily设置为sans-serif就行了。 骨骼动画目前没法直接用DragonBones的Runtime（我是Demo都跑不出来的那种不能用），但可以使用Spine的，直接到Phaser3主项目的plugins/spine/dist目录下就能找到这个插件了，在HTML里加载，然后在全局配置里加上 plugins: { scene: [ { key: 'SpineWebGLPlugin', plugin: SpineWebGLPlugin, start: true } ] }, 就能用了。另外在DragonBones输出Spine格式的时候要注意，我个人不推荐用编辑器直出，而更建议用DragonBones Tools这个工具转换已有的DragonBones文件，主要是因为编辑器直出的是3.3版本的(spine)文件，而转换出来的则是3.6。不过转换出来还需要检查下json主配置文件，里边有个deform字段，其下可能会存在一个空字符串主键导致报错，改成&quot;default&quot;即可。还有，this.load.spine之前可以先用this.load.setPath设置下路径，这样json文件和atlas文件可以不用再写整段路径了，还有png素材也不用去单独指定路径了。再补充下，如果DragonBones动画里使用了ik，到网页上时ik可能会出现完全失效的情况，会使动画出现“鬼畜”（实际是由于失去了ik的约束，使原有骨骼出现了错位），这是因为 DragonBones导出的Spine JSON文件中，ik字段数组下的每个成员都缺少了一个order字段（其实就是排序），加上之后就没问题了。 说一下预加载。预加载一般单独放个Scene里，比如可以叫loader，那么loader需要的资源就在loader.preload回调里加载，然后整个H5需要用到的资源放到loader.create回调里加载（实际就是动态加载）。另外注意在create回调里加载资源的时候，最后需要加一句this.load.start()启动加载。至于progress和complete这俩事件就不多说了。 如果不是全站CDN(HTML文件在普通服上，其它静态资源在CDN)，可以在HTML文件的&lt;head&gt;里加个&lt;base&gt;标签设置CDN基地址，相对比较方便。 对于数量限定的位图字体，比如只在游戏计分出现的字体（只有数字），用RetroFont是最方便的。切图处理时需要注意，要把所有用到的字符单独输出等大的图片，然后横向拼到一张图里，加载时按普通图片加载就行，初始化需要用RetroFont的方式： this.cache.bitmapFont.add('my_num', Phaser.GameObjects.RetroFont.Parse(this, { image: 'my_num', width: 52, height: 83, chars: '0123456789', // 指定图里都是什么字符 charsPerRow: 10, // 每行字符数 spacing: { x: 0, y: 0 } // 每字符相隔像素数 })) 然后就可以直接按bitmaptext那样去用了this.add.bitmapText(106, 64, &#39;my_num&#39;, &#39;012&#39;) 全局配置，直接放代码了： var config = { type: Phaser.AUTO, // 一般用Phaser.AUTO就行，很少有项目需要强行指定Phaser.WEBGL的。Canvas那项我觉得没啥用 // backgroundColor: 0x1b1b1d, // 看项目需要，如果需要背景色时可以直接在这里设置 render: { antialias: true, // 抗锯齿，建议开 transparent: true // Canvas容器背景透明，如果有和DOM有交互时这项可以开，记得把背景色关掉 }, canvasStyle: 'overflow:hidden;', // 在这里设置Canvas容器的行内样式 banner: false, // 把这项关掉，就不会在控制台输出Phaser引擎版本之类自带的调试信息了 scale: { width: 750, // 建议把设置稿尺寸写这里，会按这个尺寸缩放 height: 1206, mode: Phaser.Scale.ENVELOP, // 适配方式，Phaser.Scale.ENVELOP就相当于是cover，而Phaser.Scale.FIT相当于contain autoCenter: Phaser.Scale.CENTER_BOTH, // 居中方式，有CENTER_HORIZONTALLY、CENTER_VERTICALLY和CENTER_BOTH三种可选 max: { // 指定适配后的最大尺寸，这里限制一下，在pc端会美观一点(不会出现尺寸特别大的情况) width: 1080, height: 1920 } }, physics: { default: 'arcade', // 物理引擎，一般不大的需求用arcade就够了 arcade: { debug: false } // arcade设置，打开debug可以看到刚体的定界框 }, input: { mouse: false, // 移动端项目一般关掉mouse，不然会出点透bug activePointers: 1 // 多指触摸限制，不过貌似用处不大 }, disableContextMenu: true, loader: { crossOrigin: 'anonymous' // 避免图片跨域 }, scene: [loader, home, game] // 这里放每一个Scene的变量，初始化完成后默认加载第一个Scene }","categories":[{"name":"前端","slug":"前端","permalink":"https://marsgt.github.io/categories/前端/"}],"tags":[{"name":"随手记","slug":"随手记","permalink":"https://marsgt.github.io/tags/随手记/"},{"name":"javascript","slug":"javascript","permalink":"https://marsgt.github.io/tags/javascript/"},{"name":"Phaser3","slug":"Phaser3","permalink":"https://marsgt.github.io/tags/Phaser3/"}]},{"title":"【转】使用React和HTML5表单验证API处理表单元素","slug":"【转】使用React和HTML5表单验证API处理表单元素","date":"2019-04-22T07:29:00.000Z","updated":"2019-04-22T09:03:11.545Z","comments":true,"path":"2019/04/22/【转】使用React和HTML5表单验证API处理表单元素/","link":"","permalink":"https://marsgt.github.io/2019/04/22/【转】使用React和HTML5表单验证API处理表单元素/","excerpt":"作者: Dmitry Sheiko | 译：甄玉磊 原文地址：Handling forms with React and HTML5 Form Validation API 译文地址：【译】使用React和HTML5表单验证API处理表单元素 (最近在折腾 React，表单这块想用原生校验，找资料时发现了这篇文章。原译文代码的部分有些乱，所以处理了一下并转到这里。)","text":"作者: Dmitry Sheiko | 译：甄玉磊 原文地址：Handling forms with React and HTML5 Form Validation API 译文地址：【译】使用React和HTML5表单验证API处理表单元素 (最近在折腾 React，表单这块想用原生校验，找资料时发现了这篇文章。原译文代码的部分有些乱，所以处理了一下并转到这里。) 【译者注：链接序号对应下面扩展阅读，另外可以点击阅读原文查看详细的链接文章】 简介：React 没有内置的表单验证逻辑，但是我们可以使用第三方解决方案。这种方法可能是开发包、表单生成器，还可能是 HOC 或者是包含校验逻辑的任意表单容器组件。那么选择哪种方法呢？我们将在本文中一 一介绍。 每当我们提及应用程序中的用户输入框时，首先映入脑海的就是 HTML 的表单元素。最早的 HTML 版本就已经支持 Web 表单。众所周知，这一特性于 1991 年提出，且在 1995 年作为 RFC（征求评议文件） 1866 号协议[1]标准化。与此同时表单元素也得到了广泛应用，几乎每一个代码库和框架中都在使用。那么在 React 中如何使用呢？ Facebook 在如何处理表单上提供了受控的输入框[2]。该输入框指的是受控表单，主要是通过交互事件和通过 value 属性传递 state 值实现对输入框的控制。因此，你可以决定表单的校验和提交逻辑。拥有好的用户体验的 UI ，意味着你应该考虑到诸如“提交”、“校验”的逻辑以及内联的错误提示信息，根据有效性、原始状态和提交状态来切换元素。难道我们不能提取这种逻辑，简单的插入到表单元素中吗？当然可以，唯一要考虑的问题是我们要采用何种方法和解决方案。 组件库中的表单 如果你习惯使用诸如 ReactBootstrap[3] 或者 AntDesign[4] 等 React 组件库，很可能已经对其中的表单组件感到满意。这两个组件库所提供的表单组件满足了多种需求。例如在 AntDesign 组件库中我们定义了一个表单元素 Form 以及带有表单域的 FormItem ，即包裹了任意输入控制的容器。你可以在 FormItem 设置校验规则： &lt;FormItem> {getFieldDecorator('select', { rules: [ { required: true, message: 'Please select your country!' }, ], })( &lt;Select placeholder=\"Please select a country\"> &lt;Option value=\"china\">China&lt;/Option> &lt;Option value=\"use\">U.S.A&lt;/Option> &lt;/Select> )} &lt;/FormItem> 举例来说，在处理表单提交时，你可以执行 this.props.form.validateFields() 来验证。这样看起来似乎所有事情都考虑到了。然而该解决方案是针对框架的。如果你没有使用这些组件库，则无法使用该方法。 基于schema构建表单 或者我们可以基于 JSON 细则构建单独的表单组件，例如我们可以引入 Winterfell 组件[5]，构建如下所示的表单组件 &lt;Winterfell schema={loginSchema} >&lt;/Winterfell> 然而这个方案是相当复杂的[6]。除此之外，我们还需要满足特定的语法。类似的另一种解决方案 react-jsonschema-form[7]，依赖于 JSON schema[8]。JSON schema 是一种与项目无关的数据文档，用来注释和校验 JSON 文档。但是，它可以将我们定义的特有属性应用在项目中，且在文档中定义。 Formsy（译者注：一种 React 表单验证组件） 我更倾向于使用一种具有逻辑校验，适用于任意 HTML 表单的组件。其中最常用的方法是—— Formsy[9]。是什么样的结构呢？我构建了自己的表单组件，并用HOC（Higher-Order Components，高阶组件）把 Formsy 包裹起来： import { withFormsy } from \"formsy-react\"; import React from \"react\"; class MyInput extends React.Component { changeValue = ( event ) => { this.props.setValue( event.currentTarget.value ); } render() { return ( &lt;div> &lt;input onChange={ this.changeValue } type=\"text\" value={ this.props.getValue() || \"\" } /> &lt;span>{ this.props.getErrorMessage() }&lt;/span> &lt;/div> ); } } export default withFormsy( MyInput ); 如上所示，组件的 props 属性中接收了 getErrorMessage() 函数，该函数可以用来生成行内错误提示信息。这样我们开发了一个输入域组件，将其放入表单中如下所示： import Formsy from \"formsy-react\"; import React from \"react\"; import MyInput from \"./MyInput\"; export default class App extends React.Component { onValid = () => { this.setState({ valid: true }); } onInvalid = () => { this.setState({ valid: false }); } submit( model ) { //... } render() { return ( &lt;Formsy onValidSubmit={this.submit} onValid={this.onValid} onInvalid={this.onInvalid}> &lt;MyInput name=\"email\" validations=\"isEmail\" validationError=\"This is not a valid email\" required >&lt;/MyInput> &lt;button type=\"submit\" disabled={ !this.state.valid }>Submit&lt;/button> &lt;/Formsy> ); } } 我们指定所有需要验证的区域都会添加 validations 属性（详见 validations 列表属性[10]）。使用 validationError 属性来设置所期望的校验信息，通过 onValid 和 onInvalid 接收表单校验状态。 这样看上去很简单、干净、灵活。但是我想知道的是为什么我们不依赖 HTML5 的表单验证[11]，而是使用繁多的自定义实现呢？ HTML5表单验证 这项技术在很早之前就出现了，首次实现是在 2008 年的 Opera 9.5 中。现在所有的现代浏览器都支持它。表单（数据）验证[12]引入额外的 HTML 属性和 input 类型，这些可以用来设置表单的校验规则。这些校验还可以使用特有的 API [13]来控制和自定义表单JavaScript。 让我们看下面的代码： &lt;form> &lt;label for=\"answer\">What do you know, Jon Snow?&lt;/label> &lt;input id=\"answer\" name=\"answer\" required> &lt;button>Ask&lt;/button> &lt;/form> 这是一个简单的表单，期望的功能 —— &lt;input&gt; 元素有required的属性。因此，如果我们快速按下提交按钮，表单内容不会提交到服务器。相反我们会看到在输入框旁出现提示信息，提示 value 值没有满足给出的限制条件（不能为空）。 现在我们给输入框增加约束条件： &lt;form> &lt;label for=\"answer\">What do you know, Jon Snow?&lt;/label> &lt;input id=\"answer\" name=\"answer\" required pattern=\"nothing|nix\"> &lt;button>Ask&lt;/button> &lt;/form> 错误提示信息并没有给出我们期望的信息，不是吗？我们可以自定义它（例如为了解释所期望的用户输入值）或者仅仅对输入值进行转换。 &lt;form> &lt;label for=\"answer\">What do you know, Jon Snow?&lt;/label> &lt;input id=\"answer\" name=\"answer\" required pattern=\"nothing|nix\"> &lt;button>Ask&lt;/button> &lt;/form> const answer = document.querySelector( \"[name=answer]\" ); answer.addEventListener( \"input\", ( event ) => { if ( answer.validity.patternMismatch ) { answer.setCustomValidity(\"Oh, it's not a right answer!\"); } else { answer.setCustomValidity( \"\" ); } }); 以上代码只是检查 input 框的输入事件，其校验状态 patternMismatch 的变化。当输入的值与定义的 pattern 不匹配时，就会出现错误提示信息。如果我们设置了其他的限制条件[14]，也会被我们所定义的事件处理函数所覆盖。 你对这个工具提示不太满意？是的，它在不同的浏览器中表现形式是不一样的。让我们给表单元素增加novalidate属性，并且自定义错误提示： &lt;form novalidate> &lt;label for=\"answer\">What do you know, Jon Snow?&lt;/label> &lt;input id=\"answer\" name=\"answer\" required pattern=\"nothing|nix\"> &lt;div data-bind=\"message\">&lt;/div> &lt;button>Ask&lt;/button> &lt;/form> const answer = document.querySelector( \"[name=answer]\" ), answerError = document.querySelector( \"[name=answer] + [data-bind=message]\" ); answer.addEventListener( \"input\", ( event ) => { answerError.innerHTML = answer.validationMessage; }); 尽管这个介绍比较简短，你也能体会到技术背后的力量和灵活性。最重要的是，它是原生的表单验证。所以我们为什么要依赖繁多的自定义库。而不去使用原生的验证呢？ 满足表单校验的 React API react-html5-form 将 React（还可以选择Redux） 和 HTML5 表单校验 API 联系起来了。它提供 From 组件和 InputGroup 组件（类似于 Formsy 组件库中的 input，或者 AntDesign 组件库中的 FormItem ）。这样，Form 组件定义了表单及其作用区域。InputGroup 组件可以包含一个或多个输入框。我们简单地用这些组件包裹一个任意的表单内容（只是普通的 HTML 或 React 组件）。在用户事件上，我们可以请求表单验证，并根据有效的输入值，获得 Form 和 InputGroup 组件的更新状态。 好了，让我们实践一下，首先我们定义表单区域： import React from \"react\"; import { render } from \"react-dom\"; import { Form, InputGroup } from \"Form\"; const MyForm = props => ( &lt;Form> {({ error, valid, pristine, submitting, form }) => ( &lt;> Form content &lt;button disabled={ ( pristine || submitting ) } type=\"submit\">Submit&lt;/button> &lt;/> )} &lt;/Form> ); render( &lt;MyForm >&lt;/MyForm>, document.getElementById( \"app\" ) ); 作用域接收到的状态对象具有以下属性： error - 表单错误信息（通常指的是服务端的校验信息），可以通过 form.setError() 进行设置； valid - 布尔值，表示所有的输入是否全部满足规定的约束； pristine - 布尔值，表示用户是否和表单进行过交互； submitting - 布尔值，表示是否正在提交表单（当用户按下提交按钮时该状态转化为 true，一旦用户定义的异步提交逻辑处理结束，该值变为 false） form - 用于访问表单组件 API 的表单实例； 在这里我们使用 pristine 和 submitting 属性将提交按钮切换为禁用状态。 为了在提交表单的同时校验表单输入信息，我们使用 InputGroup 包裹这些input表单。 &lt;InputGroup validate={[ \"email\" ]}> {({ error, valid }) => ( &lt;div> &lt;label htmlFor=\"emailInput\">Email address&lt;/label> &lt;input type=\"email\" required name=\"email\" id=\"emailInput\" /> { error &amp;&amp; (&lt;div className=\"invalid-feedback\">{error}&lt;/div>) } &lt;/div> )} &lt;/InputGroup> 使用 validate 属性我们可以指定该组内应该使用什么样的 input。[“email”] 意味着我们只有一个名称为“email”的input。 在这个作用区域内我们接收到的状态对象具有下面的属性： errors – 所有注册 input 的错误信息数组； error – 最后显示的错误信息； valid – 布尔值，表示是否所有的输入数据全部满足规定的约束条件； inputGroup – 访问表单组件 API 的实例； 渲染之后我们可以得到一个 email 类型的输入框。如果该值为空，或在提交时包含无效的电子邮件地址，则在输入框旁边显示相应的验证消息。 还记得我们在使用原生表单校验 API 自定义错误提示信息时的焦头烂额吗？使用 InputGroup 这一情况将变得好转： &lt;InputGroup validate={[ \"email\" ]} translate={{ email: { valueMissing: \"C'mon! We need some value\", typeMismatch: \"Hey! We expect an email address here\" } }}> ... 我们可以将每个 input 定义为 key-value 的哈希结构，其中 keys 表示有效性属性[15]，values 表示自定义消息。 自定义消息很简单。那么自定义验证该如何实现呢？我们可以使用校验的 prop 来做到： &lt;InputGroup validate={{ \"email\": ( input ) => { if ( !EMAIL_WHITELIST.includes( input.current.value ) ) { input.setCustomValidity( \"Only whitelisted email allowed\" ); return false; } return true; } }}> ... 在这个例子中，我们提供的是包含输入框名字的哈希而不是数组，其中 key 是输入框的名字， value 是验证处理函数。处理函数校验输入值（可以异步完成）并返回一个布尔类型的有效状态。使用 input.setCustomValidity，我们可以自定义验证消息。 输入框并不总是提交时才进行校验。为了达到实时验证，首先我们需要给输入事件定义事件处理函数： const onInput = ( e, inputGroup ) => { inputGroup.checkValidityAndUpdate(); }; 事实上，我们可以在用户每次输入时重新验证。控制逻辑如下所示： &lt;input type=\"email\" required name=\"email\" onInput={( e ) => onInput( e, inputGroup, form ) } id=\"emailInput\" /> 这样，每当输入值改变时都会进行验证。如果输入值是无效的，我们就会马上收到错误的提示信息。 你可以通过这里找到以上示例的源代码[16]。 顺便说一句，你是否考虑过将组件派生的表单状态树和 Redux 存储值联系起来？我们也可以这样做。 Redux 提供了包含所有注册表单状态树的 reducer：html5form。我们可以按照如下所示将 html5form 和 store 结合起来： import React from \"react\"; import { render } from \"react-dom\"; import { createStore, combineReducers } from \"redux\"; import { Provider } from \"react-redux\"; import { App } from \"./Containers/App.jsx\"; import { html5form } from \"react-html5-form\"; const appReducer = combineReducers({ html5form }); // Store creation const store = createStore( appReducer ); render( &lt;Provider store={store}> &lt;App >&lt;/App> &lt;/Provider>, document.getElementById( \"app\" ) ); 当我们运行该应用程序时，就能在 store 中找到所有与表单相关的状态。 点击这里[17]查看上述 demo 的源代码。 总结 React 没有内置的表单验证逻辑，但是我们可以使用第三方解决方案。这种方法可能是开发包、表单生成器，还可能是 HOC 或者是包含校验逻辑的任意表单容器组件。我个人倾向于使用容器组件，该组件依赖于 HTML 内置表单验证 API ，并在表单和表单域的范围中显示有效性状态。 react-html5-form 源代码[18] 演示例子链接[19] 扩展阅读 https://tools.ietf.org/html/rfc1866 https://reactjs.org/docs/forms.html https://react-bootstrap.github.io/components/forms/ https://ant.design/components/form/ https://github.com/andrewhathaway/Winterfell https://github.com/andrewhathaway/Winterfell/blob/master/examples/schema.js https://github.com/mozilla-services/react-jsonschema-form http://json-schema.org/ https://github.com/formsy/formsy-react https://github.com/formsy/formsy-react/blob/master/API.md#validators https://developer.mozilla.org/en-US/docs/Learn/HTML/Forms/Form_validation https://developer.mozilla.org/en-US/docs/Learn/HTML/Forms/Form_validation https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/HTML5/Constraint_validation https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/HTML5/Constraint_validation https://developer.mozilla.org/en-US/docs/Web/API/ValidityState https://github.com/dsheiko/react-html5-form/blob/master/demo/bootstrap/src/index.jsx https://github.com/dsheiko/react-html5-form/blob/master/demo/bootstrap-redux/src/index.jsx https://github.com/dsheiko/react-html5-form https://dsheiko.github.io/react-html5-form","categories":[{"name":"经验技巧","slug":"经验技巧","permalink":"https://marsgt.github.io/categories/经验技巧/"},{"name":"React","slug":"经验技巧/React","permalink":"https://marsgt.github.io/categories/经验技巧/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://marsgt.github.io/tags/React/"}],"author":"作者: Dmitry Sheiko | 译：甄玉磊"},{"title":"OpenWRT路由器设置界面中的Lua填坑","slug":"OpenWRT路由器设置界面中的Lua填坑","date":"2019-03-05T02:18:50.000Z","updated":"2019-03-08T00:54:45.671Z","comments":true,"path":"2019/03/05/OpenWRT路由器设置界面中的Lua填坑/","link":"","permalink":"https://marsgt.github.io/2019/03/05/OpenWRT路由器设置界面中的Lua填坑/","excerpt":"刚结束一个急活，主要是整理某个 OpenWRT 路由的设置界面，网页服务主要用的是 Nginx，网页用的是 BackBone 和 jQuery 配合，后端设置服务主要用的是 Lua（由 Nginx 代理）调用 OpenWRT 的 UCI 和 ubus。一开始我以为只需要前端稍微调整下就行了，后来发现后边跟着的 Lua 得一起整，顺带补了不少 OpenWRT 的基础知识，下边简单梳(还)理(债)……","text":"刚结束一个急活，主要是整理某个 OpenWRT 路由的设置界面，网页服务主要用的是 Nginx，网页用的是 BackBone 和 jQuery 配合，后端设置服务主要用的是 Lua（由 Nginx 代理）调用 OpenWRT 的 UCI 和 ubus。一开始我以为只需要前端稍微调整下就行了，后来发现后边跟着的 Lua 得一起整，顺带补了不少 OpenWRT 的基础知识，下边简单梳(还)理(债)…… UCI 基础知识 UCI 是“Unified Configuration Interface”（统一配置界面）的缩写，是 OpenWrt 系统的核心配置框架，它的主要作用是整合系统里不同的设置项，并提供一个统一的接口。OpenWrt 系统配置文件默认被集中放在了 /etc/config 这里（当然也可以放在其它地方），这些 UCI 文件有自己特殊的语法，比如一个典型的无线配置可能是： config wifi-device &#39;radio0&#39; option type &#39;mac80211&#39; option channel &#39;auto&#39; option hwmode &#39;11g&#39; option path &#39;platform/qca953x_wmac&#39; option htmode &#39;HT20&#39; option disabled &#39;0&#39; config wifi-iface option ifname &#39;wlan0&#39; option device &#39;radio0&#39; option network &#39;lan&#39; option mode &#39;ap&#39; option encryption &#39;none&#39; option ssid &#39;TestSSID&#39; 这里以 config 开头的行代表了一个 config 节点，其格式为：config &#39;section-type&#39; &#39;section&#39;section-type 处的值是节点类型，而 section 则是节点名称。另外，config 节点允许匿名节点的存在（意即直接跳过&#39;section&#39;，就像第二个的 config 节点那样，wifi-iface只是节点类型而不是节点名，这里要注意），引号在 UCI 文件中也不是必须的，严格来讲只有值里带有空格或制表符时才需要使用，使用时也要注意，其必须成对出现才有效（比如一对单引号或者一对双引号，交叉使用会导致语法错误）。以 option 开头的是选项，格式为：option &#39;key&#39; &#39;value&#39;这是比较典型的 key-value 格式，就不再赘述了。除此之外，还有种 list 列表选项，被用来描述形如数组类的设置，格式与 option 非常相似：list &#39;list-key&#39; &#39;list-value&#39;如果 list-key 相同的话，那么这实际上就是个数组式的设置项，举个栗子，system 设置里的 NTP： config timeserver &#39;ntp&#39; option enabled &#39;1&#39; option enable_server &#39;0&#39; list server &#39;0.openwrt.pool.ntp.org&#39; list server &#39;1.openwrt.pool.ntp.org&#39; list server &#39;2.openwrt.pool.ntp.org&#39; list server &#39;3.openwrt.pool.ntp.org&#39; 这里的 NTP Server 设置实际上就是个数组。 UCI 的调用 在 OpenWRT 系统里调用 UCI 一般有两种方法，通过命令行或者是调用 Lua API。这里首先说命令行。OpenWRT 官方文档里提到，使用awk、grep等命令来解析Openwrt的配置文件是低效和不明智的做法，并建议在类似的场景下，应该优先使用命令行形式调用。UCI 命令行语法为（在命令行下直接输入 uci 即可看到）： 用法: uci [&lt;options&gt;] &lt;command&gt; [&lt;arguments&gt;] 命令: batch export [&lt;config&gt;] import [&lt;config&gt;] changes [&lt;config&gt;] commit [&lt;config&gt;] add &lt;config&gt; &lt;section-type&gt; add_list &lt;config&gt;.&lt;section&gt;.&lt;option&gt;=&lt;string&gt; show [&lt;config&gt;[.&lt;section&gt;[.&lt;option&gt;]]] get &lt;config&gt;.&lt;section&gt;[.&lt;option&gt;] set &lt;config&gt;.&lt;section&gt;[.&lt;option&gt;]=&lt;value&gt; delete &lt;config&gt;[.&lt;section[.&lt;option&gt;]] rename &lt;config&gt;.&lt;section&gt;[.&lt;option&gt;]=&lt;name&gt; revert &lt;config&gt;[.&lt;section&gt;[.&lt;option&gt;]] 参数: -c &lt;path&gt; 设置用于存储配置文件的文件夹 (默认位于: /etc/config) -d &lt;str&gt; 使用&#39;uci show&#39;命令时，为 list 类型的值设置分隔符 -f &lt;file&gt; 使用指定的 &lt;file&gt; 作为输入，而不是默认的 stdin -m 导入时，合并数据到现有的设置中 -n 导出时，命名匿名节 (默认) -N 不要命名匿名节 -p &lt;path&gt; 添加一个配置文件的搜索路径 -P &lt;path&gt; 添加一个配置文件的搜索路径并将其作为默认设置 -q 安静默认 (不打印错误信息) -s 强制使用严格模式 (在解析出现错误时停止，默认) -S 关闭严格模式 -X 在&#39;show&#39;命令上显示匿名节点ID (如果有的话) 平时（命令行下）常用的主要是 show，get，set，changes 和 commit 这几个。使用 UCI 时，需要特别注意下它的读写规则：UCI 在读取时，会首先读取内存中的缓存，而后才是文件；而写入则与此相反，增删改都是在操作缓存，需要手动提交才会将设置项写入到系统中。所以，在编写路由设置系统时，最后的提交操作是切不可忘的一步。还有一种调用 UCI 的方法，是使用 Lua，文末的参考内容[3]中有详细的 API 列表（记得在开头用 local uci = require &quot;los.uci&quot;.cursor() 语句引入）。在使用 Lua 调用时，有个需要注意的点是匿名节点，比如上文中的无线配置里，有个 wifi-iface 类型的匿名节点，在命令行里使用 uci show wireless 可以看到： wireless.radio1=wifi-device wireless.radio1.type=&#39;mac80211&#39; wireless.radio1.channel=&#39;auto&#39; wireless.radio1.hwmode=&#39;11g&#39; wireless.radio1.path=&#39;platform/qca953x_wmac&#39; wireless.radio1.htmode=&#39;HT20&#39; wireless.radio1.disabled=&#39;0&#39; wireless.@wifi-iface[0]=wifi-iface wireless.@wifi-iface[0].ifname=&#39;wlan0&#39; wireless.@wifi-iface[0].device=&#39;mt7620&#39; wireless.@wifi-iface[0].network=&#39;lan&#39; wireless.@wifi-iface[0].mode=&#39;ap&#39; wireless.@wifi-iface[0].encryption=&#39;none&#39; wireless.@wifi-iface[0].ssid=&#39;TestSSID&#39; 这里可以看到很多键名类似 @wifi-iface[0] 的设置项，这就是匿名节点的设置项了。如果在命令行里加入 -X 参数变成 uci -X show wireless，则可以看到： wireless.radio1=wifi-device wireless.radio1.type=&#39;mac80211&#39; wireless.radio1.channel=&#39;auto&#39; wireless.radio1.hwmode=&#39;11g&#39; wireless.radio1.path=&#39;platform/qca953x_wmac&#39; wireless.radio1.htmode=&#39;HT20&#39; wireless.radio1.disabled=&#39;0&#39; wireless.cfg043579=wifi-iface wireless.cfg043579.ifname=&#39;wlan1&#39; wireless.cfg043579.device=&#39;radio1&#39; wireless.cfg043579.network=&#39;lan&#39; wireless.cfg043579.mode=&#39;ap&#39; wireless.cfg043579.encryption=&#39;none&#39; wireless.cfg043579.ssid=&#39;TestSSID&#39; 这时 @wifi-iface[0] 变成了 cfg043579，这才是这个匿名节点真实的引用名（系统自动生成的）。而同样的，在撰写相对应的 Lua 语句时，也不能写成： uci:get(\"wireless\", \"@wifi-iface[0]\", \"ssid\", \"NewSSID\") 虽然可以在命令行执行 uci set wireless.@wifi-iface[0].ssid=&#39;NewSSID&#39;，但是在 Lua 上这么写系统是不会鸟你的（更何况还有个隐性的问题，是设置被改动过后，匿名节点的位置有可能会变，比如会跑到 @wifi-iface[1] 去，这可能会发生在拥有多个匿名节点的配置文件里）。所以这个时候，就需要使用 uci:foreach 去遍历某个设置类型的所有设置节点（注：返回 false 终止遍历），在遍历出的内容里，有几个特殊的、键名以英文字符 . 开头的成员： [.index]: 设置节点的索引 [.name]: 设置节点的名称（即真实的引用名，cfg043579 这种） [.type]: 设置节点的类型（如 wifi-iface） [.anonymous]: 指示该设置节点是否匿名 这样，通过遍历所有项目并筛选符合条件的配置项，将 [.name] 中的内容缓存下来，就可以用： uci:get(\"wireless\", \"cfg043579\", \"ssid\", \"NewSSID\") 这种方法去调用了。这里放个自己写的用于遍历无线设置的函数（双频设备，每个频段只有一个信号，通过设备 ID 来识别）： function getWirelessInfo() local wifiConfig = {} uci:foreach( \"wireless\", \"wifi-iface\", function(s) if s.device == \"mt7620\" then if not wifiConfig.mt7620 then wifiConfig[\"mt7620\"] = {} end local key = \"\" if s.key then key = s.key end wifiConfig.mt7620 = { name = s[\".name\"], ssid = s.ssid, ency = s.encryption, pass = key } elseif s.device == \"mt7612\" then if not wifiConfig.mt7612 then wifiConfig[\"mt7612\"] = {} end local key = \"\" if s.key then key = s.key end wifiConfig.mt7612 = { name = s[\".name\"], ssid = s.ssid, ency = s.encryption, pass = key } end end ) return wifiConfig end 不过，在实践中，我认为最有效的手段是将匿名节点转化成普通的具名节点，这样 Lua 就可以直接调用，比写挨个遍历内容的逻辑要简单也清晰的多。 下边再说说 ubus。 ubus ubus 即是 OpenWrt micro bus 架构，是 OpenWrt 为了提供守护进程和应用程序间的通讯而开发的项目。简单来说，想获取系统运行的一些状态，是可以用 ubus 来查看的，而且相比用 UCI 查询，由于 ubus 获取的直接是系统信息而不是设置项，所以可以避免由于错误配置带来的配置项与系统状态不符合的问题。也是因为这个原因，我推荐读取设置(状态)时用 ubus，写入设置时用 UCI。当然 ubus 也并不是没有问题，目前比较通用的说法是，在数据内容超过 60k 时不建议用，另外如果有多线程、或者逻辑上有递归时也不建议用（指令发出以后，接受到的信息可能是另一条指令的返回内容）。 ubus 的调用 同 UCI 类似，调用 ubus 也分为命令行方式与 Lua 调用方式。而与 UCI 将设置文件命名为包（package）不同的是，ubus 将其调度单位称为“命名空间”（namespace），系统后台会默认驻留一个名为 ubusd 的守护进程，使用友好的 JSON 格式进行交互。在命令行中输入 ubus list 就可以看到所有通过RPC服务器注册的命名空间： dhcp hostapd.wlan0 hostapd.wlan1 log network network.device network.interface network.interface.lan network.interface.loopback network.interface.wan network.interface.wan6 network.wireless service session system uci 加个参数变成 ubus -v list，就可以详细列出这些命名空间所提供的方法了。调用方法用 call 关键字，比如，查看系统 WiFi 状态就可以用： ubus call network.wireless status '{}' （参数一定要带上，即使为空。格式为 JSON） 除此以外，还有： 获取系统信息（上线时间、内存用量、SWAP信息等） ubus call system info '{}' 获取设备信息（设备型号、固件版本等） ubus call system board '{}' 获取 WiFi 上已连接的客户端 ubus call hostapd.wlan0 get_clients '{}' 获取路由物理设备信息（如 MAC 型号、工作状态等） ubus call network.device status '{\"name\":\"eth0\"}' 等等。除了命令行直接调用外，ubus 也可以使用 Lua 调用，由于没有 UCI 那劳什子匿名节点的问题，所以直接用 local ubus = require \"ubus\" 引入，在调用前用 local conn = ubus.connect() 连接服务，在调用后用 conn:close() 关闭就好。比如我自己写的一段从 ubus 上拿 WiFi 信息的函数： local function getWirelessStatus() local conn = ubus.connect() if not conn then error(\"Failed to connect to ubusd\") end local info = {} local status = conn:call(\"network.wireless\", \"status\", {}) for k, v in pairs(status) do info[k] = v end conn:close() return info end 参考内容 OpenWRT官网 - UCI系统 OpenWRT官网 - UCI技术参考资料 LuaDoc - luci.model.uci (英) OpenWRT官网 - ubus","categories":[{"name":"经验技巧","slug":"经验技巧","permalink":"https://marsgt.github.io/categories/经验技巧/"}],"tags":[{"name":"随手记","slug":"随手记","permalink":"https://marsgt.github.io/tags/随手记/"},{"name":"OpenWRT","slug":"OpenWRT","permalink":"https://marsgt.github.io/tags/OpenWRT/"}]},{"title":"Git提交信息样式指南","slug":"Git提交信息样式指南","date":"2019-01-24T02:34:53.000Z","updated":"2019-01-24T03:00:12.124Z","comments":true,"path":"2019/01/24/Git提交信息样式指南/","link":"","permalink":"https://marsgt.github.io/2019/01/24/Git提交信息样式指南/","excerpt":"本文节选自优达学城Git 提交信息样式指南，部分内容略有修改。","text":"本文节选自优达学城Git 提交信息样式指南，部分内容略有修改。 提交信息 信息结构 提交信息由三个不同的部分构成，这些部分均由空行分隔：标题、可选的消息体和可选的注释。其布局大致如此： 类型：主题 消息正文 注释 标题由消息类型和主题构成。 类型 类型位于在标题内，有以下几种可能： feature： 新功能 fix：错误修复 docs：文档修改 style：格式、分号缺失等，代码无变动 refactor：生产代码重构 test：测试添加、测试重构等，生产代码无变动 chore：构建任务更新、程序包管理器配置等，生产代码无变动。 主题 主题不得超过50个字符，首字母大写，末尾不加句号。 以祈使语气描述提交的任务，而不是其已完成的任务。例如，使用 change …，而不是 changed 或 changes 。 信息正文 并不是所有的提交信息都复杂到需要主体，因此这是可选内容，仅在提交信息需要一定的解释和语境时使用。消息体是用于解释提交任务的内容和原因，而不是方法。在编写正文时，需要在标题和正文间加一个空行，且每行的内容应控制在72个字符内。 注释 注释是可选内容，用于引用 issue 的 ID 。 提交信息示例 feature: 总结变动的内容，保持在50个字符内 如有需要，使用更详细的说明性文字，将其大概控制在72个字符。在部分语境中，第一行被视为提交信息的主题，余下的文本被视为主体。分隔总结与主体的空行十分重要（除非你完全忽略主体）；否则`log`、`shortlog`和`rebase`等多个工具容易发生混淆。 解释该提交信息所解决的问题，说明你进行该变动的原因，而不是方法（代码本身可以解释方法）。 该变动是否存在副作用或其他直觉性后果？在这里进行解释。 后续段落前需加空行。 可以列出要点 - 通常情况下，要点会使用空格加上连字符或星号，中间用空行分隔，但该规定存在差别。 如果你使用问题追踪，将其引用放在末尾，例如： 解决了问题：#123 另见：#456, #789","categories":[{"name":"经验技巧","slug":"经验技巧","permalink":"https://marsgt.github.io/categories/经验技巧/"},{"name":"版本管理","slug":"经验技巧/版本管理","permalink":"https://marsgt.github.io/categories/经验技巧/版本管理/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://marsgt.github.io/tags/Git/"}]},{"title":"搭建带有Web管理功能的私有Docker Registry","slug":"搭建带有Web管理功能的私有Docker-Registry","date":"2019-01-23T05:47:29.000Z","updated":"2019-01-23T06:13:04.938Z","comments":true,"path":"2019/01/23/搭建带有Web管理功能的私有Docker-Registry/","link":"","permalink":"https://marsgt.github.io/2019/01/23/搭建带有Web管理功能的私有Docker-Registry/","excerpt":"本文记录了搭建简易的(无WebUI)私有Docker Registry服务以及推送镜像的相关内容","text":"本文记录了搭建简易的(无WebUI)私有Docker Registry服务以及推送镜像的相关内容 搭建单一Docker Registry请见《搭建私有Docker Registry以及推送镜像》，本文不再赘述 搭建带有Web管理功能的私有Docker Registry，分别需要Nginx（域名解析及反代，这里直接使用宿主机上编译好的）、Docker Registry及Docker Registry Web（提供Web管理界面） 为了配置方便，关掉了用户名密码功能，改为使用阿里云安全组直接限制80端口的入方向IP(外网为固定IP或者从某一固定IP代理) 使用Docker-Compose编排，配置文件： version: '3' services: registry-srv: image: registry:2.4 ports: - \"9527:5000\" volumes: - /var/lib/docker/registry:/var/lib/registry environment: - REGISTRY_STORAGE_FILESYSTEM_ROOTDIRECTORY=/var/lib/registry - REGISTRY_STORAGE_DELETE_ENABLED=true restart: always registry-web: image: hyper/docker-registry-web ports: - \"29527:8080\" volumes: - /var/lib/docker/registry/web:/data environment: - REGISTRY_URL=http://172.19.0.1:9527/v2 - REGISTRY_NAME=registry.hahahaha.com - REGISTRY_READONLY=false restart: always depends_on: - registry-srv registry-srv是私有Docker Registry服务，用的是简配（没上配置文件，只映射了部分环境变量和容器存储位置。把环境变量的“REGISTRY”前缀去掉，改成小写再把下划线改写成层级，就是YAML配置）；registry-web是Web界面服务，registry.hahahaha.com的DNS解析和阿里云安全组需要配置下，环境变量里“REGISTRYURL”是需要连接到的私有Docker Registry服务，这里的172.x.0.1的地址是和容器同网段的宿主机地址（不要用URL，访问不了；也不要用localhost，容器内的localhost不会指向宿主机） 然后需要配一下Nginx的反代。分别发到上文的9527和29527端口即可。 在Docker-Compose配置文件使用docker-compose up -d命令拉起服务，然后用docker-compose logs -f命令监控，直到出来“Server startup……”等内容时，nginx -s reload，然后访问registry.hahahaha.com就能看到管理界面了。","categories":[{"name":"经验技巧","slug":"经验技巧","permalink":"https://marsgt.github.io/categories/经验技巧/"},{"name":"开发工具","slug":"经验技巧/开发工具","permalink":"https://marsgt.github.io/categories/经验技巧/开发工具/"}],"tags":[{"name":"随手记","slug":"随手记","permalink":"https://marsgt.github.io/tags/随手记/"},{"name":"部署","slug":"部署","permalink":"https://marsgt.github.io/tags/部署/"},{"name":"Docker","slug":"Docker","permalink":"https://marsgt.github.io/tags/Docker/"}]},{"title":"搭建私有Docker Registry以及推送镜像","slug":"搭建私有Docker-Registry以及推送镜像","date":"2019-01-23T05:26:41.000Z","updated":"2019-01-23T06:11:40.511Z","comments":true,"path":"2019/01/23/搭建私有Docker-Registry以及推送镜像/","link":"","permalink":"https://marsgt.github.io/2019/01/23/搭建私有Docker-Registry以及推送镜像/","excerpt":"本文记录了搭建简易的(无WebUI)私有Docker Registry服务以及推送镜像的相关内容","text":"本文记录了搭建简易的(无WebUI)私有Docker Registry服务以及推送镜像的相关内容 首先需要生成连接用的用户名密码，用htpasswd。安装直接yum install -y httpd-tools，然后htpasswd -cB /home/.passwd hahahaha 或者上边也可以直接用registry镜像中的htpasswd代替，使用docker run --entrypoint htpasswd registry -Bbn \\[用户名] \\[密码] &gt;&gt; /etc/docker/auth/registry.htpasswd来生成 用户名hahahaha，密码Haha123，服务搭在公网88.88.88.88主机上，端口19527 构建指令： docker run -d -p 9527:5000 --name registry --restart=always \\\\ -v /etc/docker/registry:/var/lib/registry \\\\ -v /etc/docker/auth:/auth \\\\ -e REGISTRY_AUTH=htpasswd \\\\ -e REGISTRY_AUTH_HTPASSWD_REALM=\"Registry Realm\" \\\\ -e REGISTRY_AUTH_HTPASSWD_PATH=/auth/passwd \\\\ registry 详细教程可以参考：Docker私有Registry搭建教程 /etc/docker/daemon.json文件中的内容建议改为： { \"registry-mirrors\": [\"https://registry.docker-cn.com\"], \"insecure-registries\": [\"88.88.88.88:9527\"] } PUSH镜像前，需新增镜像Tag，用docker tag命令将其转成URL[:PORT]/REPO:TAG这种格式，比如用：docker tag hahahaha/admin-test:develop 88.88.88.88:9527/hahahaha/admin-test:develop命令代表准备将 hahahaha/admin-test 镜像推到 88.88.88.88:9527 然后用docker login登录 接着用docker push 88.88.88.88:9527/hahahaha/admin-test:develop直接推就行 推完以后打开浏览器，输入http://88.88.88.88:9527/v2/登录一下，然后再打开http://88.88.88.88:9527/v2/_catalog就能看到刚推上去的镜像了。（Docker Registry HTTP API V2）","categories":[{"name":"经验技巧","slug":"经验技巧","permalink":"https://marsgt.github.io/categories/经验技巧/"},{"name":"开发工具","slug":"经验技巧/开发工具","permalink":"https://marsgt.github.io/categories/经验技巧/开发工具/"}],"tags":[{"name":"随手记","slug":"随手记","permalink":"https://marsgt.github.io/tags/随手记/"},{"name":"部署","slug":"部署","permalink":"https://marsgt.github.io/tags/部署/"},{"name":"Docker","slug":"Docker","permalink":"https://marsgt.github.io/tags/Docker/"}]},{"title":"内网服务器部署Gitea的简单记录","slug":"内网服务器部署Gitea的简单记录","date":"2019-01-23T02:36:41.000Z","updated":"2019-01-23T06:11:47.880Z","comments":true,"path":"2019/01/23/内网服务器部署Gitea的简单记录/","link":"","permalink":"https://marsgt.github.io/2019/01/23/内网服务器部署Gitea的简单记录/","excerpt":"对部署Gitea的简单记录","text":"对部署Gitea的简单记录 主机：CentOS选型：用了DockerCE+Gitea DockerCE和Docker的区别在，前者是最新版（免费的社区版，17.X+），后者是老版本（1.X+），另外还有个企业版是DockerEE Gitea是Gogs的一个开源分支版本，因为Gogs的Docker版本一直有点问题，所以就改用它了。 首先需要部署Docker。默认会带老版本的Docker，这里需要全部卸载： sudo yum remove docker docker-common docker-selinux docker-engine 然后安装需要的软件包： sudo yum install -y yum-utils device-mapper-persistent-data lvm2 添加安装源并加到本地缓存： sudo yum-config-manager --add-repo https://download.docker.com/linux/docker-ce.repo sudo yum makecache fast 安装docker-ce并启动（加自启） sudo yum install docker-ce sudo systemctl start docker sudo chkconfig docker on docker官方的镜像服务基本跑不动，所以需要把镜像源改成国内的加速地址。改地址一般有两种方式（详细可参阅Docker 中国官方镜像加速），一是在pull镜像时，在前边加上加速地址的URL，比如要下载gitea/gitea:latest，就可以： sudo docker pull registry.docker-cn.com/gitea/gitea:latest 或者还有种方式是更改/etc/docker/daemon.json文件，编辑为： { \"registry-mirrors\": [\"https://registry.docker-cn.com\"] } 这样就可以直接用： sudo docker pull gitea/gitea:latest 来下载了。 这时等进度条走完，就已经下载好了Gitea的镜像，可以用： sudo docker image ls 来查看系统里已有的镜像；这里会看到镜像会有个ImageID，这个下边有用。 新建一个目录，用于将容器内的存储映射到当前系统内： sudo mkdir -p /var/lib/gitea 然后启动容器： docker run -d --name=gitea -p 10022:22 -p 10080:3000 -v /var/lib/gitea:/data 737fb3dad067 其中-d参数是后台运行，-p参数是将容器内端口映射到系统端口（系统:容器内），-v参数是将容器内存储位置映射到系统相应位置（系统:容器内），最后一行ID是ImageID，以实际查到的为准（不写标签主要是防止服务器慢时重复下载，这里也可以直接写镜像URL直接下载启动） 打开192.168.1.10:10080，就可以看到WebUI了。 配置文件位置：/var/lib/gitea/gitea/conf/app.ini（配置项参考） 配置后需要重启下容器： sudo docker restart gitea","categories":[{"name":"经验技巧","slug":"经验技巧","permalink":"https://marsgt.github.io/categories/经验技巧/"},{"name":"开发工具","slug":"经验技巧/开发工具","permalink":"https://marsgt.github.io/categories/经验技巧/开发工具/"}],"tags":[{"name":"随手记","slug":"随手记","permalink":"https://marsgt.github.io/tags/随手记/"},{"name":"Gitea","slug":"Gitea","permalink":"https://marsgt.github.io/tags/Gitea/"},{"name":"部署","slug":"部署","permalink":"https://marsgt.github.io/tags/部署/"}]},{"title":"在NexT主题下添加Gitalk的简单记录","slug":"在NexT主题下添加Gitalk的简单记录","date":"2018-12-29T07:08:08.000Z","updated":"2018-12-30T12:02:41.444Z","comments":true,"path":"2018/12/29/在NexT主题下添加Gitalk的简单记录/","link":"","permalink":"https://marsgt.github.io/2018/12/29/在NexT主题下添加Gitalk的简单记录/","excerpt":"简单记录下如何在NexT主题下添加Gitalk评论插件。","text":"简单记录下如何在NexT主题下添加Gitalk评论插件。 Gitalk是一个基于GitHub Issue的评论插件，优点是可以利用GitHub Pages自带的issue来做评论功能，相对一些NexT主题自带的评论插件来说，因为不用去注册第三方平台帐号，也不用做域名备案（连域名都没😂……还要啥🚲啊），所以更加简便易行。 好，下边直接说步骤吧：首先，要去申请个GitHub Application，用来授权给Gitalk插件读取和写入GitHub Pages项目issue内容。Homepage URL和Authorization callback URL就写成博客地址就行，Authorization name和Authorization description随便写就可以。填好提交之后会生成一个Client ID和Client Secret，内容复制备用；接下来，找到NexT主题目录下的layout\\_custom\\sidebar.swig这个文件，在其中加入： {% if page.comments and config.gitalk.enable %} var gitalk = new Gitalk({ clientID: '{{ config.gitalk.clientID }}', clientSecret: '{{ config.gitalk.clientSecret }}', repo: '{{ config.gitalk.repo }}', owner: '{{ config.gitalk.owner }}', admin: '{{ config.gitalk.admin }}', id: md5(location.pathname), distractionFreeMode: 'true', pagerDirection: 'first' }); var div = document.createElement('div'); div.setAttribute(\"id\", \"gitalk_comments\"); div.setAttribute(\"class\", \"post-nav\"); var bro = document.getElementById('posts').getElementsByTagName('article'); bro = bro[0].getElementsByClassName('post-block'); bro = bro[0].getElementsByTagName('footer'); bro = bro[0]; bro.appendChild(div); gitalk.render('gitalk_comments'); {% endif %} 然后找到Hexo全局_config.yml配置文件，在其中加入： # Gitalk评论 gitalk: enable: true owner: #Github用户名# admin: #Github用户名# repo: #Github Pages项目名# clientID: #clientID# clientSecret: #clientSecret# gitalk_css: //cdn.bootcss.com/gitalk/1.4.1/gitalk.min.css gitalk_js: //cdn.bootcss.com/gitalk/1.4.1/gitalk.min.js md5: //cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.min.js 最后hexo clean清下缓存，再hexo g重新生成就可以了。 写这篇文章的时候，才发现我所用的NexT主题版本中已经集成了gitalk，用的是Hexo NexT主题中集成gitalk评论系统中的方案，所以在NexT主题下的_config.yml配置文件中的gitalk相应配置项填一下就能开启了。不过需要注意的是这个版本没用pagerDirection这个配置项，如果需要的话在NexT主题的layout\\_third-party\\comments\\gitalk.swig文件中line:30加个,pagerDirection: 然后在配置里加一行pager_direction的配置就行了。","categories":[{"name":"经验技巧","slug":"经验技巧","permalink":"https://marsgt.github.io/categories/经验技巧/"},{"name":"Hexo","slug":"经验技巧/Hexo","permalink":"https://marsgt.github.io/categories/经验技巧/Hexo/"}],"tags":[{"name":"随手记","slug":"随手记","permalink":"https://marsgt.github.io/tags/随手记/"},{"name":"Hexo","slug":"Hexo","permalink":"https://marsgt.github.io/tags/Hexo/"}]},{"title":"PHP上的SQLite初体验","slug":"PHP上的SQLite初体验","date":"2018-12-20T13:32:03.000Z","updated":"2018-12-28T05:20:32.135Z","comments":true,"path":"2018/12/20/PHP上的SQLite初体验/","link":"","permalink":"https://marsgt.github.io/2018/12/20/PHP上的SQLite初体验/","excerpt":"这两天在折腾一个小的推广页面，里边有个需求是提交表单和数据汇总，估了下压力应该不大，懒得再折腾MySQL服务了，就想试试SQLite。我后端主要是用PHP打配合，查了下文档，SQLite在PHP上主要有纯原生的SQLite扩展和数据库抽象层PDO(PHP数据对象)两种调用方式。由于之前写MySQL的时候接触过PDO，所以这次也优先选择了这种方式","text":"这两天在折腾一个小的推广页面，里边有个需求是提交表单和数据汇总，估了下压力应该不大，懒得再折腾MySQL服务了，就想试试SQLite。我后端主要是用PHP打配合，查了下文档，SQLite在PHP上主要有纯原生的SQLite扩展和数据库抽象层PDO(PHP数据对象)两种调用方式。由于之前写MySQL的时候接触过PDO，所以这次也优先选择了这种方式 （主要是换个DSN就行了，可以节省一些学习成本😜）。数据库还需要一个图形界面来打配合（需要展示数据的场景，我个人认为GUI会比CLI有优势；当然如果换成命令行也行），MySQL的时候有个现成的NaviCat for MySQL，但并不通用；所以我就上网去搜有什么软件可以用。最先映入眼帘的是SQLiteStudio，开源、绿色（Portable版本）、多平台，搜到的讨论也很多，就去下载下来试了下。喏：第一感觉就是：丑！丑爆了……不过丑可能是Qt的通病吧，暂且按下不表。但我选的语言配置是中文诶，连菜单都没覆盖到是什么鬼😤……好吧抛开这些不谈，软件基本能用，就先开工吧。 既然有了工具辅助，那么就可以开始建库了。此处建议先行补一下SQLite的基础知识，我是直接看的菜鸟教程……权威倒不敢说，贵在简单。SQLite大概是最迷你的关系数据库系统了，小就小在没有很多大型数据库的各种高级功能，自然也可以做到相对轻量和快速。SQLite的类型系统不像MySQL那样默认支持SQL的所有数据类型，它使用一种类似解释型语言的动态类型系统，默认类型(即Storage Class，存储类型)只有NULL、INTEGER(整型)、REAL(浮点型)、TEXT(字符串)和BLOB(二进制)这几种；而在核心类型以外，还存在一种被称为类型关联(Type Affinity)的概念(菜鸟将此处译做“亲和类型”)，即将多个类型映射成几个近似的基本类型，以确保SQLite可以支持更多的类型。在具体实现上，相关的映射关系： 来自语句中的类型 最终关联类型 INTINTEGERTINYINTSMALLINTMEDIUMINTBIGINTUNSIGNED BIG INTINT2INT8 INTEGER CHARACTER(20)VARCHAR(255)VARYING CHARACTER(255)NCHAR(55)NATIVE CHARACTER(70)NVARCHAR(100)TEXTCLOB TEXT BLOBno datatype specified NONE REALDOUBLEDOUBLE PRECISIONFLOAT REAL NUMERICDECIMAL(10,5)BOOLEANDATEDATETIME NUMERIC 可以看到也是5个类型。不过Type Affinity并不是必须的，最终的类型另外还有两个类型，布尔型和日期/时间类型，前者会被转换为整型的0(FALSE)和1(TRUE)，后者则会被存储为TEXT、REAL或INTEGER。 好，到这时，就可以到SQLiteStudio中实践一下了。打开软件，找到”Database-&gt;Add a database”，类型选SQLite3就可以，点绿加号选择文件的保存位置，下边的Name其实是在左侧列表中显示的名字，点确定就可以了。一开始还没建表，所以一片灰什么都没……右击”Tables”选择”Create a table”，打开列表设计页，输入”Table name”之后就可以建表了。双击空白处打开字段编辑框，然后按一般套路去搞就行了。这里我需要提交的表单信息很少，所以除了必要的姓名手机号以外，就多建了个id(多说一句，勾上主键点开配置，勾上”Autoincrement”就是自增)。 插一句，在折腾的过程中又发现了一个GUI程序DB Browser for SQLite，体验比SQLiteStudio好太多：DB Browser很符合我心目中对数据库浏览器的要求：足够简单(就SQLite而言)、界面友好(全中文覆盖完全)、功能实际(有个细节，在新建字段时，默认只提供INTEGER、TEXT、NONE、REAL、NUMERIC这5种，起码在我看来这降低了复杂度，且符合原有设计)，所以建议换这个。 表设计的差不多，就可以开搞PHP这边了。数据库操作选择了用PDO来实现，因为之前写过……PDO的好处就是对于实现了驱动的数据库，换个DSN就行了，后边再用SQL指令、事务操作什么的都是通用的。所以有： &lt;?php header('content-type: text/html;charset=utf-8'); header('Cache-Control: no-cache'); try { $pdo = new PDO('sqlite:../data/test.db'); // 指向数据库文件 $pdo->exec('set names utf8'); // 设置操作编码 $pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION); // 遇错误抛出异常 } catch (PDOExceiption $e) { exit('ERROR!'); } 当然这只是完成了最基本的功能：连接，如果没有错误发生的话，它连报错也不会。所以在后边，需要加一点SQL语句进去，鉴于我的需求主要是写入数据，所以我们需要在这里加上预处理语句。什么是预处理语句呢？可以把它看作是想要运行的SQL的一种编译过的模板，它可以使用变量参数进行定制。那么接下来： &lt;?php header('content-type: text/html;charset=utf-8'); header('Cache-Control: no-cache'); try { $pdo = new PDO('sqlite:../data/test.db'); // 指向数据库文件 $pdo->exec('set names utf8'); // 设置操作编码 $pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION); // 遇错误抛出异常 $sql = 'INSERT INTO user (user, phone, city) VALUES (:user, :phone, :city)'; // 这里用的是冒号式的具名占位符，也可以用`?`来做匿名占位符，下边绑定时改用数字序号就行 $stmt = $pdo->prepare($sql); $stmt->bindParam(':user', $user); //绑定占位符对应的值 $stmt->bindParam(':phone', $phone); $stmt->bindParam(':city', $city); $stmt->execute(); } catch (PDOExceiption $e) { exit('ERROR!'); } 到这里，前边的代码基本能跑了。但是可以留意到错误处理这块还是很简陋，没有error信息也没有留下log，那么把这里完善一下： &lt;?php header('content-type: text/html;charset=utf-8'); header('Cache-Control: no-cache'); try { $pdo = new PDO('sqlite:../data/test.db'); // 指向数据库文件 $pdo->exec('set names utf8'); // 设置操作编码 $pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION); // 遇错误抛出异常 $sql = 'INSERT INTO user (user, phone, city) VALUES (:user, :phone, :city)'; // 这里用的是冒号式的具名占位符，也可以用`?`来做匿名占位符，下边绑定时改用数字序号就行 $stmt = $pdo->prepare($sql); $stmt->bindParam(':user', $user); //绑定占位符对应的值 $stmt->bindParam(':phone', $phone); $stmt->bindParam(':city', $city); $stmt->execute(); } catch (PDOExceiption $e) { $now = date('Y-m-d H:m:s'); $msg = '[time][' . $now . '][msg][' . $e->getMessage() . ']' . \"\\n\"; error_log($msg, 3, '../log/error.log'); } 那么到了这里，这段代码基本就算能开跑了。当然还是建议根据需要加上return语句，这里不多赘述。","categories":[{"name":"经验技巧","slug":"经验技巧","permalink":"https://marsgt.github.io/categories/经验技巧/"},{"name":"后端","slug":"经验技巧/后端","permalink":"https://marsgt.github.io/categories/经验技巧/后端/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://marsgt.github.io/tags/PHP/"},{"name":"SQLite","slug":"SQLite","permalink":"https://marsgt.github.io/tags/SQLite/"},{"name":"数据库","slug":"数据库","permalink":"https://marsgt.github.io/tags/数据库/"}]},{"title":"在Hexo nexT主题上添加多个字体","slug":"在Hexo-nexT主题上添加多个字体","date":"2018-12-12T13:15:56.000Z","updated":"2018-12-12T14:09:42.728Z","comments":true,"path":"2018/12/12/在Hexo-nexT主题上添加多个字体/","link":"","permalink":"https://marsgt.github.io/2018/12/12/在Hexo-nexT主题上添加多个字体/","excerpt":"折腾Hexo的第一篇，先聊聊多字体设置。","text":"折腾Hexo的第一篇，先聊聊多字体设置。 官方自带的主题市场溜达了一圈，也没看到什么感兴趣的，后来发现怎么好几个博客都在用nexT？那就装上试试吧。从&thinsp;Github&thinsp;上下载、安装、改设置一气呵成，清掉之前的重新生成，Bingo！翻了翻这主题真的不错，要用的一些插件基本集成全了，还自带一个网站用来&thinsp;Step by Step&thinsp;教怎么用，真的贴心到家了~使用中发现了一个痛点，就是不知道默认样式怎么设置多个字体，文档里提到的next\\_config.yml里的font设置包括给到的&thinsp;Demo&thinsp;只适合单个字体，但我自己习惯上需要设置多个字体回退（包括现在在码字的&thinsp;VSCode&thinsp;都是）的，So， 怎么办？ 上网搜了下，资料不是很多，只有一篇&thinsp;2017&thinsp;年的文章提到要改next\\source\\css\\_variables\\base.styl文件，我一看，我去这&thinsp;Stylus&thinsp;啊，当初觉得门槛高就没碰过，没想到在这又……好吧硬着头皮去找文档。除了官方文档以外，能用的只有张鑫旭维护的Stylus中文文档还能看，简单瞅了几眼，然后对着代码开撸~按照之前那篇文章里所写，先在family里设置长字符串，然后回到&thinsp;styl&thinsp;文件的函数里去除引号，但找了好几圈，也没发现stylus哪里提供了去除掉引号的方法，或者说，就没找到完整的字符串类型操作函数……于是放弃。由于之前折腾&thinsp;Docker&thinsp;的时候，学了点&thinsp;Yaml&thinsp;语法，这时突然想，把配置直接写成数组形式行不行？于是我写成了这样： global: external: false family: - -apple-system - BlinkMacSystemFont - Segoe UI Emoji - Helvetica Neue - Helvetica - Nimbus Sans L - Arial - Liberation Sans - Hiragino Sans GB - Source Han Sans CN Normal - Microsoft YaHei - 微软雅黑 - Wenquanyi Micro Hei - WenQuanYi Zen Hei - ST Heiti - SimHei - WenQuanYi Zen Hei Sharp size: 再在&thinsp;styl&thinsp;文件里直接放变量，然后拼接尾部的, sans-serif，好的hexo g生成！然后惊喜的发现数组内容是以空格连接直接输出的，这……好吧，我改用自带的join()函数拼接下试试~但是试了几次，最后输出的内容都会被一对引号包起来，甚至连一开始的空格都没了，这……一筹莫展之际，发现base.styl下边还有个custom.styl，咦？试着直接把需要的样式直接写进去： $font-family-base = -apple-system, BlinkMacSystemFont, \"Segoe UI Emoji\", \"Helvetica Neue\", Helvetica, \"Nimbus Sans L\", Arial, \"Liberation Sans\", \"Hiragino Sans GB\", \"Source Han Sans CN Normal\", \"Microsoft YaHei\", \"微软雅黑\", \"Wenquanyi Micro Hei\", \"WenQuanYi Zen Hei\", \"ST Heiti\", SimHei, \"WenQuanYi Zen Hei Sharp\", sans-serif $font-family-monospace = \"Fira Code\", \"更纱黑体 UI SC\", consolas, Menlo, \"Segoe UI Emoji\", monospace 然后hexo g生成……居然搞定了！哈哈😄~生成的内容就是我想要的！ 所以方法就是这样，不要管_config.yml和base.styl里的东西，直接在custom.styl里重写相应的变量就行了~ 如果本文对你有帮助，欢迎在下方打赏我哦！谢谢😁~","categories":[{"name":"经验技巧","slug":"经验技巧","permalink":"https://marsgt.github.io/categories/经验技巧/"},{"name":"Hexo","slug":"经验技巧/Hexo","permalink":"https://marsgt.github.io/categories/经验技巧/Hexo/"}],"tags":[{"name":"随手记","slug":"随手记","permalink":"https://marsgt.github.io/tags/随手记/"},{"name":"Hexo","slug":"Hexo","permalink":"https://marsgt.github.io/tags/Hexo/"},{"name":"Yaml","slug":"Yaml","permalink":"https://marsgt.github.io/tags/Yaml/"},{"name":"Stylus","slug":"Stylus","permalink":"https://marsgt.github.io/tags/Stylus/"}]},{"title":"Hello, World.","slug":"Hello-World","date":"2018-11-06T04:13:12.000Z","updated":"2018-12-30T01:54:51.621Z","comments":true,"path":"2018/11/06/Hello-World/","link":"","permalink":"https://marsgt.github.io/2018/11/06/Hello-World/","excerpt":"","text":"Hello world, Hexo. 此站点正式启用。","categories":[{"name":"HelloWorld","slug":"HelloWorld","permalink":"https://marsgt.github.io/categories/HelloWorld/"}],"tags":[{"name":"随手记","slug":"随手记","permalink":"https://marsgt.github.io/tags/随手记/"},{"name":"Hexo","slug":"Hexo","permalink":"https://marsgt.github.io/tags/Hexo/"},{"name":"HelloWorld","slug":"HelloWorld","permalink":"https://marsgt.github.io/tags/HelloWorld/"}]},{"title":"关于iOS 11.x微信连wifi流程中，在Portal页无法拉起微信问题的简单记录","slug":"关于iOS-11-x微信连wifi流程中，在Portal页无法拉起微信问题的简单记录","date":"2018-08-31T08:01:13.000Z","updated":"2018-12-30T01:47:29.831Z","comments":true,"path":"2018/08/31/关于iOS-11-x微信连wifi流程中，在Portal页无法拉起微信问题的简单记录/","link":"","permalink":"https://marsgt.github.io/2018/08/31/关于iOS-11-x微信连wifi流程中，在Portal页无法拉起微信问题的简单记录/","excerpt":"标题挺长，踩过坑的应该看的明白。不过限于目前所做产品流程的限制，我并没有解决掉这个问题，只是简单说一下相应的思路。","text":"标题挺长，踩过坑的应该看的明白。不过限于目前所做产品流程的限制，我并没有解决掉这个问题，只是简单说一下相应的思路。 iOS的系统浏览器是Safari，用于Portal认证的则是CNA（Captive Network Assistant），二者的区别在于前者可以打开wachat:这种私有协议头网址，后者无法打开并且限制很多，比如无法使用alert()、无法正常使用window.open()（只能做跳转）等等。 问题的症结在于在新版的CNA中是不认wechat:这样的私有协议头的，所以自然也就拉不起来微信。解决时需要引导用户点击a标签&lt;a target=&quot;_system&quot;&gt;&lt;/a&gt;触发Safari，然后再在Safari拉起微信就行了。 我目前的portal触发逻辑是，客户端连到wifi上回触发landing，首先返回码设定为401用于触发客户端的portal页面，同时判断客户端UA，如果是部分安卓或iOS就渲染landing实体页（landing.ejs），页面的title和body均为“Success”以作为iOS欺骗（并且会加快从连接到弹出portal的响应时间）；js部分，ios是直接打开认证URL，针对部分安卓则是加了判断document.visibilityState == &#39;visible&#39;时触发跳转的事件，用来解决不弹portal的问题。但由于点击按钮之后就直接进到js拉微信认证的流程了（少一步引导拉起微信），所以其实需要部分变更产品流程才行（这个版本暂时没戏）。 参考链接： iOS: Open a Welcome Page in Safari, not CNA 微信连WI-Fi解决ios无法呼出微信","categories":[{"name":"经验技巧","slug":"经验技巧","permalink":"https://marsgt.github.io/categories/经验技巧/"},{"name":"移动端","slug":"经验技巧/移动端","permalink":"https://marsgt.github.io/categories/经验技巧/移动端/"}],"tags":[{"name":"随手记","slug":"随手记","permalink":"https://marsgt.github.io/tags/随手记/"},{"name":"微信","slug":"微信","permalink":"https://marsgt.github.io/tags/微信/"},{"name":"WiFi","slug":"WiFi","permalink":"https://marsgt.github.io/tags/WiFi/"},{"name":"iOS","slug":"iOS","permalink":"https://marsgt.github.io/tags/iOS/"},{"name":"Portal","slug":"Portal","permalink":"https://marsgt.github.io/tags/Portal/"}]},{"title":"win10+vscode部署java开发环境","slug":"win10-vscode部署java开发环境","date":"2018-05-15T08:36:44.000Z","updated":"2018-12-30T01:46:42.583Z","comments":true,"path":"2018/05/15/win10-vscode部署java开发环境/","link":"","permalink":"https://marsgt.github.io/2018/05/15/win10-vscode部署java开发环境/","excerpt":"最近在学Java，嫌IDE太重，就自己摸索了一下用VScode部署Java开发环境的方法，比较适合轻度入门级、以及对比较熟VScode不想换编辑器的搞法。","text":"最近在学Java，嫌IDE太重，就自己摸索了一下用VScode部署Java开发环境的方法，比较适合轻度入门级、以及对比较熟VScode不想换编辑器的搞法。 部署JDK其实之前在大概1.5的时候就看过一点Java的东西，也装过JDK还有JRE，也装过Eclipse，但是前边那俩太占系统资源了，后边的又太丑，没多久就让我全给卸了。这回一开始装的时候，其实我也试过装JDK，但是也还是和之前一个德行，直到我看到了OpenJDK……卧槽要的就是这个！直接到它的下载里把东西拖回来解压，然后到开始菜单打开“设置”（齿轮图标），直接搜索“高级”，点击“查看高级系统设置”打开“系统属性”窗口，再点“环境变量…”按钮打开“环境变量”，在上边用户变量里加个JAVA_HOME的变量，值就是你JDK解压到的位置（可以直接用浏览目录选择）；再点开“Path”，在下边新增一项%JAVA_HOME%\\bin，全部确定退出去就可以了。这时可以用Win+R并输入cmd打开命令提示符窗口，输入java -version能看到OpenJDK版本信息的话，就说明搞定了。 部署MavenMaven其实也是类似于JDK这种，直接去官网点Download，直接找到Binary zip archive的Link直接下载就行，也是拖到一个地方解压，然后点开“环境变量”，在用户变量里分别加个M2_HOME，都指向解压目录，然后再到Path里加个%M2_HOME%\\bin全部确定就可以了。验证时到cmd里输下mvn -v，同样如果有版本信息那就是成功了。 在VScode里安装相关插件及配置Microsoft有个官方的插件“Java Extension Pack”，点开它的“依赖项”可以看到就是需要装的几个插件，可以直接装这个（会附带把依赖项都装上）或者单装都可以，装好以设置下java.home、maven.executable.path和maven.terminal.useJavaHome基本就能跑了，当然记得把terminal.integrated.shell.windows也要一并设置好。 配置MAVEN国内代理首先打开MAVEN的解压目录，然后找到conf文件夹，把settings.xml文件复制到用户文件夹的.m2文件夹下，然后找到&lt;mirrors&gt;这段，添加： &lt;mirror> &lt;id>alimaven&lt;/id> &lt;name>aliyun maven&lt;/name> &lt;url>http://maven.aliyun.com/nexus/content/groups/public/&lt;/url> &lt;mirrorOf>central&lt;/mirrorOf> &lt;/mirror> &lt;mirror> &lt;id>central&lt;/id> &lt;name>Maven Repository Switchboard&lt;/name> &lt;url>http://repo1.maven.org/maven2/&lt;/url> &lt;mirrorOf>central&lt;/mirrorOf> &lt;/mirror> &lt;mirror> &lt;id>repo2&lt;/id> &lt;mirrorOf>central&lt;/mirrorOf> &lt;name>Human Readable Name for this Mirror.&lt;/name> &lt;url>http://repo2.maven.org/maven2/&lt;/url> &lt;/mirror> &lt;mirror> &lt;id>ibiblio&lt;/id> &lt;mirrorOf>central&lt;/mirrorOf> &lt;name>Human Readable Name for this Mirror.&lt;/name> &lt;url>http://mirrors.ibiblio.org/pub/mirrors/maven2/&lt;/url> &lt;/mirror> &lt;mirror> &lt;id>jboss-public-repository-group&lt;/id> &lt;mirrorOf>central&lt;/mirrorOf> &lt;name>JBoss Public Repository Group&lt;/name> &lt;url>http://repository.jboss.org/nexus/content/groups/public&lt;/url> &lt;/mirror> &lt;mirror> &lt;id>maven.net.cn&lt;/id> &lt;name>oneof the central mirrors in china&lt;/name> &lt;url>http://maven.net.cn/content/groups/public/&lt;/url> &lt;mirrorOf>central&lt;/mirrorOf> &lt;/mirror> 进去，保存退出。 部署GradleGradle是Google家的构建系统工具，一般Android上用的更多些。由于语法是基于Groovy实现的，所以手写时会比XML爽不少。在安装上，Gradle跟其它工具大同小异，都是先去官网下载，然后解压到一个目录，再在系统里加入GRADLE_HOME变量，并把bin目录加入到Path里即可。Gradle文档可以参考Gradle 用户指南官方文档中文版。","categories":[{"name":"经验技巧","slug":"经验技巧","permalink":"https://marsgt.github.io/categories/经验技巧/"},{"name":"开发工具","slug":"经验技巧/开发工具","permalink":"https://marsgt.github.io/categories/经验技巧/开发工具/"}],"tags":[{"name":"编辑器","slug":"编辑器","permalink":"https://marsgt.github.io/tags/编辑器/"},{"name":"VSCode","slug":"VSCode","permalink":"https://marsgt.github.io/tags/VSCode/"},{"name":"JAVA","slug":"JAVA","permalink":"https://marsgt.github.io/tags/JAVA/"},{"name":"Windows10","slug":"Windows10","permalink":"https://marsgt.github.io/tags/Windows10/"}]},{"title":"jQTips · 动态添加元素的清爽写法","slug":"jQTips-·-动态添加元素的清爽写法","date":"2017-08-02T10:54:39.000Z","updated":"2018-12-30T01:46:42.583Z","comments":true,"path":"2017/08/02/jQTips-·-动态添加元素的清爽写法/","link":"","permalink":"https://marsgt.github.io/2017/08/02/jQTips-·-动态添加元素的清爽写法/","excerpt":"在写动态添加元素时，一般比较常见的写法都是","text":"在写动态添加元素时，一般比较常见的写法都是 这个样子的： var newClass = 'newDiv'; var newText = 'Demo!'; var newBody = $('&lt;div class=\"' + newClass + '\">' + newText + '&lt;/div>'); $('body').append(newBody); 如果还需要事件呢，那么就在前边加个事件委托： $(document).on('click', '.newDiv', function(){ console.info('Click Me!'); }); 但其实呢，这里可以还使用jQuery对象的包装语法，通过查询文档呢我们知道它的语法是jQuery( html, attributes )，在html参数这里，我们可以使用一个（不含任何属性的）单标签，就是类似于&quot;&lt;div /&gt;&quot;、&quot;&lt;div&gt;&quot;以及&quot;&lt;div&gt;&lt;/div&gt;&quot;这几种类型的标签，它和前边一大长串字符串那种的区别在于：前者会用innerHTML实现；而后者则是调用.createElement()实现的。 看到这里你可能会问，如果前边用了单标签，那里边这堆class啊还有内容啥的该咋办？答案就在第二个参数attributes上。attributes参数是一个对象，里边放的是第一个参数、也就是单标签里的属性，简单来说你可以将它等同于.attr(attributes)来用，并且，它还能综合.val()、.css()、.html()、.text()、.data()、.width()、.height()、.offset()之类的功能，比如第一段代码就可以改写成： var newClass = 'newDiv'; var newText = 'Demo!'; $('&lt;div>', { 'class': newClass, //和.attr()一样，由于class是保留字所以要强制加引号 text: newText }).appendTo('body'); 而绑定事件也可以一并写进去，比如带有简写（即.click()）调用的click就可以这样写： var newClass = 'newDiv'; var newText = 'Demo!'; $('&lt;div>', { 'class': newClass, text: newText, click: function(){ console.info('Click Me!'); } }).appendTo('body'); 当然也可以写成： var newClass = 'newDiv'; var newText = 'Demo!'; $('&lt;div>', { 'class': newClass, text: newText, on: { click: function() { console.info('Click Me!'); } } }).appendTo('body'); 如果为一堆变量名命名发愁，也可以完全不用变量，变成： $('&lt;div>', { 'class': 'newDiv', text: 'Demo!', click: function(){ console.info('Click Me!'); } }).appendTo('body'); 看起来有没有比苦逼的字符串拼接清爽许多呢？","categories":[{"name":"经验技巧","slug":"经验技巧","permalink":"https://marsgt.github.io/categories/经验技巧/"},{"name":"前端","slug":"经验技巧/前端","permalink":"https://marsgt.github.io/categories/经验技巧/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://marsgt.github.io/tags/JavaScript/"},{"name":"jQuery","slug":"jQuery","permalink":"https://marsgt.github.io/tags/jQuery/"}]},{"title":"自己撸个简单的ps切图脚本（已弃坑）","slug":"自己撸个简单的ps切图脚本（已弃坑）","date":"2017-07-25T10:31:01.000Z","updated":"2019-01-23T02:33:28.566Z","comments":true,"path":"2017/07/25/自己撸个简单的ps切图脚本（已弃坑）/","link":"","permalink":"https://marsgt.github.io/2017/07/25/自己撸个简单的ps切图脚本（已弃坑）/","excerpt":"刚做完的一个H5项目里，为了切图方便，接触了下Photoshop的脚本功能。从找资料、写脚本到实际能用全套跑了一圈下来发现，嗯，果然是挺难用的[\\捂脸]。不过虽然缺点满满，但PS这个平台上，可以拿来做自动化切图这种事的选择并不多……所以只好将就将就咯~","text":"刚做完的一个H5项目里，为了切图方便，接触了下Photoshop的脚本功能。从找资料、写脚本到实际能用全套跑了一圈下来发现，嗯，果然是挺难用的[\\捂脸]。不过虽然缺点满满，但PS这个平台上，可以拿来做自动化切图这种事的选择并不多……所以只好将就将就咯~ ##0.准备篇 工欲善其事、必先利其器。写ps脚本除了常用的代码编辑器以外，还有个选择，就是Adobe自家的ExtendScript Toolkit CC。这里解释一下，“ExtendScript”也就是本文所讨论的ps脚本，并不只有ps可以用，AE、AI都是可以用的，不过需要调用各自不同的API。ExtendScript Toolkit的界面和操作啥的都挺路人的，只不过它有个别的代码编辑器都没有的功能，就是可以直接连接上ps，并看到ps的内部对象，另外它也能一键调用ps来执行脚本，所以我选择先用代码编辑器写脚本，然后用它来执行。 刚装好的ExtendScript Toolkit界面大概是这样的： 标签页底下前边带个绿色双锁链图标的是链接选框，作用是决定当前文档需要和哪个程序（PS、AI、AE等）链接，右边从上到下分别是console控制台、脚本库和内部对象浏览器。 看起来好像挺高大上的样子，对吧？燃鹅，万幸中的不幸是，我发现它并不能识别出我的PS……所以并没有什么卵用…… 不过装好这个工具以后，在它安装目录下（我系统是Win10，安装目录是\\Program Files (x86)\\Adobe\\Adobe ExtendScript Toolkit CC\\）会有个SDK文件夹，里边有个叫JavaScript Tools Guide CC的PDF是可以参考的（里边是一些Ps、AI、AE几个软件共用的接口，比如File、Folder啥的）；另外在Ps的安装目录下有个\\Presets\\Scripts文件夹，一些比如“文件”菜单下的“导出”里的一些功能，就是用脚本来实现的。 一些Ps脚本的线上参考资料： Adobe Photoshop Scripting ADOBE PHOTOSHOP CC 2015 SCRIPTING GUIDE ADOBE PHOTOSHOP CC 2015 JAVASCRIPT SCRIPTING REFERENCE ExtendScript Wiki 《PHOTOSHOP CC 2015 JAVASCRIPT SCRIPTING REFERENCE》常用部分汉化版 PhotoShop ExtendScript 常数表 初识Ps脚本 【弃坑……】","categories":[{"name":"经验技巧","slug":"经验技巧","permalink":"https://marsgt.github.io/categories/经验技巧/"},{"name":"Photoshop","slug":"经验技巧/Photoshop","permalink":"https://marsgt.github.io/categories/经验技巧/Photoshop/"}],"tags":[{"name":"插件","slug":"插件","permalink":"https://marsgt.github.io/tags/插件/"},{"name":"Photoshop","slug":"Photoshop","permalink":"https://marsgt.github.io/tags/Photoshop/"}]},{"title":"神经病啊！--微信同层播放器接(踩)入(坑)总结","slug":"神经病啊！-微信同层播放器接-踩-入-坑-总结","date":"2017-06-14T09:48:12.000Z","updated":"2019-01-23T02:33:06.219Z","comments":true,"path":"2017/06/14/神经病啊！-微信同层播放器接-踩-入-坑-总结/","link":"","permalink":"https://marsgt.github.io/2017/06/14/神经病啊！-微信同层播放器接-踩-入-坑-总结/","excerpt":"估计踩过微信视频这个坑的，内心都想说上一句： “神经病啊！” 而微信也终于出了个《H5同层播放器接入规范》，算是正常点了……","text":"估计踩过微信视频这个坑的，内心都想说上一句： “神经病啊！” 而微信也终于出了个《H5同层播放器接入规范》，算是正常点了…… 好了闲话不说，下边进入正题： 1. &lt;video&gt;标签里的内联播放相关属性 微信在video标签上新增了一些x5的私有属性，分别是： x5-video-player-type启用同层播放。取值固定为&#39;h5&#39;。 x5-video-player-fullscreen是否全屏。取值为&#39;true&#39;或&#39;false&#39;。 x5-video-orientation视频方向。取值分别为&#39;landscape&#39;、&#39;portrait&#39;或者&#39;landscape|portrait&#39;，分别对应横屏、竖屏及自动旋转（这个应该用的少）。 不过有一点需要注意的是，这些都是x5的私有属性，仅适用于Android平台。而跟iOS平台相关的，则是这几个属性： airplay x-webkit-airplay playsinline webkit-playsinline 其中最后两个是iOS平台下的内联播放属性，都是布尔属性，不需要赋值（存在即是true）；前两个是iOS平台下airplay的相关属性（说实话我现在也没搞明白为什么网页需要airplay属性），取值为&#39;allow&#39;或&#39;deny&#39;，通常保险起见用&#39;allow&#39;就可以。 2. CSS的属性选择及取值 微信在同层接入规范中提到了object-position这个属性，用于设置视频出现的位置。实际在尝试的过程中，搭配object-fit属性同时使用的效果会比较好。但这两个属性并不是x5私有属性，而是原生的，所以它们同时适用于Android和iOS两个平台。 object-position和object-fit这两个元素主要的作用是为“可替换元素”设置位置和大小。这里的“可替换元素”，指的是内容不受CSS显式控制的元素，比如比较典型的就是&lt;img&gt;、&lt;object&gt;、&lt;video&gt;和表单元素等。 说回视频播放。微信官方的同层接入规范中推荐的做法，是用js动态计算需要的像素值，然后给object-position属性赋值。而我自己尝试了一圈下来，发现object-position这个属性本身支持百分比取值，通常视频默认的值是&#39;50% 50%&#39;，也就是居中；全屏视频一般情况下需要贴底放，所以要把取值改成&#39;0 100%&#39;。 另一个属性object-fit，有点类似background-size属性，用来设置视频在容器内的填充方式，平时用只需要取值&#39;contain&#39;（保持宽高比填满容器）就可以了。不过这里需要留意的是，全屏下，由于视频一般都不会正好填满屏幕（宽高比差异以及输出分辨率没算顶部标题栏），会在顶部留下一条空隙。这条空隙通常是默认黑色的，如果需要更改颜色，首先要加上个&#39;display:block;&#39;（因为video默认是inline的），然后直接改background-color就OK~ 3. 视频封面 &lt;video&gt;标签里有一个与视频封面相关的属性poster，但是在使用中发现性能存在一些问题，在Android端打开视频时（加载），会有跳动的感觉，但是如果去掉，在视频加载时（preload取值&#39;auto&#39;，且未用预加载）则会显示空白页面。目前换用了背景图片的方式，但由于视频全屏播放时顶部会有空隙，所以额外加了个background-position: bottom;以及background-size: contain;（取值和视频保持一致），这样设置好的背景在播放视频时就不会漏边了。 4. 设置视频视口大小 同层接入规范里推荐在resize事件回调里设置视频视口大小，我习惯直接设置&lt;video&gt;标签的width和height，所以在resize回调里加入： $('video') .attr({ 'width': window.innerWidth + 'px', 'height': window.innerHeight + 'px' }); 就可以了。 5. UA特性探测 同层接入规范里给的，判断是否是同层播放器方法： 在微信等TBS里通过UA判断X5内核版本来区分,当版版本号&gt;036849表示支持UA示例:Mozilla/5.0 (Linux; Android 4.4.4; OPPO R7 Build/KTU84P) AppleWebKit/537.36(KHTML, like Gecko) Version/4.0 Chrome/37.0.0.0 Mobile MQQBrowser/6.8TBS/036849 Safari/537.36 MicroMessenger/6.3.27.861 NetType/WIFILanguage/zh_CN 在QQ浏览器Android版本中,当浏览器版本&gt;=7.1时开始支持UA示例：User­Agent: Mozilla/5.0 (Linux; U; Android 4.4.4; zh­cn; OPPO R7Build/KTU84P) AppleWebKit/537.36 (KHTML, like Gecko)Version/4.0Chrome/37.0.0.0 MQQBrowser/7.1 Mobile Safari/537.36 参考资料： 微信 · H5同层播放器接入规范 京东 · 视频H5のVideo标签在微信里的坑和技巧 关于如何在微信里面让video不全屏播放 H5微信播放全屏问题 HTML5中的视频音频使用详解 张鑫旭 · 半深入理解CSS3 object-position/object-fit属性 MDN · object-fit MDN · object-position MDN · 媒体相关事件 MDN · 可替换元素 Apple Developer · HTMLVideo​Element Apple Developer · HTMLMedia​Element Apple Developer · plays​Inline Apple Developer · Opting Into or Out of AirPlay","categories":[{"name":"经验技巧","slug":"经验技巧","permalink":"https://marsgt.github.io/categories/经验技巧/"},{"name":"前端","slug":"经验技巧/前端","permalink":"https://marsgt.github.io/categories/经验技巧/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://marsgt.github.io/tags/JavaScript/"},{"name":"微信","slug":"微信","permalink":"https://marsgt.github.io/tags/微信/"},{"name":"视频","slug":"视频","permalink":"https://marsgt.github.io/tags/视频/"},{"name":"HTML","slug":"HTML","permalink":"https://marsgt.github.io/tags/HTML/"}]},{"title":"随手记 - 疯狂触发滚轮事件的Mac触控板","slug":"随手记-疯狂触发滚轮事件的Mac触控板","date":"2017-02-07T14:54:49.000Z","updated":"2018-12-30T01:49:03.398Z","comments":true,"path":"2017/02/07/随手记-疯狂触发滚轮事件的Mac触控板/","link":"","permalink":"https://marsgt.github.io/2017/02/07/随手记-疯狂触发滚轮事件的Mac触控板/","excerpt":"头几天官网刚上线，就接到投诉说有问题。过去一看，我靠什么鬼？！Mac下用触控板一滑到底，——首页上用iscroll写的翻页效果直接全军覆没。","text":"头几天官网刚上线，就接到投诉说有问题。过去一看，我靠什么鬼？！Mac下用触控板一滑到底，——首页上用iscroll写的翻页效果直接全军覆没。 这个bug来的莫名其妙，问了一圈人也没什么思路，后来自己上网搜，在一个页面上找到一段关于Mac的触控板的手势滑动会疯狂触发滚轮事件的记录，但是轮到具体的解决方案就语焉不详了。没辙，靠天没用，还是靠自己吧~ 这里先简单介绍下。出问题的首页用的是iscroll插件，用snap属性做的整屏翻页的效果，翻页用鼠标滚轮驱动，这块用的是MDN上的一个滚轮事件的兼容代码，回调使用iscroll的接口完成向上/向下翻页的效果。 回到这个问题上。一开始我想用事件防抖解决，于是用setTimeout()自己写了个：触发事件后先进入延时，延时后执行函数；如果在延时内仍有事件触发，则取消原有的延时重新计时。 // 打底用的zepto.js，addWheelListener是滚轮事件的兼容插件，下同~ var wheelTimer = false; var wheelSlide = function (e) { e.preventDefault(); clearTimeout(timer); if (e.deltaY > 0) { wheelTimer = setTimeout(function(){ iScroll.next(); }, 100); } else if (e.deltaY &lt; 0 &amp;&amp; iScroll.currentPage.pageY != 0) { wheelTimer = setTimeout(function(){ iScroll.prev(); }, 100); } } addWheelListener($('body')[0], wheelSlide); 我本意是用延时抵消掉重复触发的滚轮事件，最后合成一个事件触发，没想到测试之后，Mac上的问题并没有解决。 于是我想，用事件防抖的思路处理应该还是不对，即便是延迟时间较短，如果事件持续触发的话肯定翻页还是会被无限的延迟阻塞掉，至此我想换用事件节流再试试。在找资料的时候，意外发现了Underscore.js这个工具库，里边不仅有现成的节流和防抖（中文文档里用的是“防反跳”）函数可以用，而且还支持链式调用，并且压缩版本也才十几k，正合我意。 说干就干，马上用Underscore撸了个事件节流版的： var wheelSlide = _(function (e) { e.preventDefault(); if (e.deltaY > 0) { iScroll.next(); } else if (e.deltaY &lt; 0 &amp;&amp; iScroll.currentPage.pageY != 0) { iScroll.prev(); } }).throttle(400);//这里毫秒数用了400，大概相当于一个短动画的执行时间 addWheelListener($('body')[0], wheelSlide); 链式写法看上去还挺不错的！进本机浏览器（PC）……嗯？为啥最后会跳一下？赶紧翻文档，又加了个参数上去： var wheelSlide = _(function (e) { e.preventDefault(); if (e.deltaY > 0) { iScroll.next(); } else if (e.deltaY &lt; 0 &amp;&amp; iScroll.currentPage.pageY != 0) { iScroll.prev(); } }).throttle(400, {trailing: false}); addWheelListener($('body')[0], wheelSlide); 这回PC上倒是正常了，Mac也从一滑到底变成了有“段落感”的跳动，但结果还是不对……一狠心把毫秒数改成了5000，结果呢：还、是、不、对、、、。。。（//陷入循环懵逼状态ing……）痛定思痛，一定是文档看的不够多！于是又啃了一遍Underscore.js的文档（虽然是翻译的，囧……），发现防抖居然有个[immediate]参数，是可以优先执行的！大喜过望~接着撸： var wheelSlide = _(function (e) { e.preventDefault(); if (e.deltaY > 0) { wScroll.next(); } else if (e.deltaY &lt; 0 &amp;&amp; wScroll.currentPage.pageY != 0) { wScroll.prev(); } }).debounce(600, true);// 本来想改回400的，有点心虚所以又加了200…… addWheelListener($('body')[0], wheelSlide); 居然PC和Mac都能一页页的翻页了有！没！有！不过翻页的动作还有点迟滞，于是果断把毫秒数改小：400、200、100，……Bingo！ 最终代码： var wheelSlide = _(function (e) { e.preventDefault(); if (e.deltaY > 0) { wScroll.next(); } else if (e.deltaY &lt; 0 &amp;&amp; wScroll.currentPage.pageY != 0) { wScroll.prev(); } }).debounce(50, true); addWheelListener($('body')[0], wheelSlide); 总结： Mac触控板bug踩坑 +1； 理解了事件节流和事件防抖的概念； Underscore.js真好用； 感谢git把每次的修改都记了下来。","categories":[{"name":"经验技巧","slug":"经验技巧","permalink":"https://marsgt.github.io/categories/经验技巧/"},{"name":"前端","slug":"经验技巧/前端","permalink":"https://marsgt.github.io/categories/经验技巧/前端/"}],"tags":[{"name":"随手记","slug":"随手记","permalink":"https://marsgt.github.io/tags/随手记/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://marsgt.github.io/tags/JavaScript/"}]},{"title":"简单记录个a标签点不上的bug","slug":"简单记录个a标签点不上的bug","date":"2016-12-31T07:47:12.000Z","updated":"2018-12-30T01:48:22.677Z","comments":true,"path":"2016/12/31/简单记录个a标签点不上的bug/","link":"","permalink":"https://marsgt.github.io/2016/12/31/简单记录个a标签点不上的bug/","excerpt":"官网改版时碰到的问题。简单记录下","text":"官网改版时碰到的问题。简单记录下 ： 【 问题 】 官网index页面移动端测试时，发现底部页脚的a标签无论如何点不动。 【 Debug 过程 】 1、先是在pc端用浏览器模拟手机看了下，问题重现； 2、然后看了下“规则”和“计算后”面板（用的是FireFox，习惯了……分别对应Chrome的styles和computed），a标签本身的样式似乎是没问题的，周围也没啥问题…… 3、丢到chrome里，问题依然重现，继续懵逼…… 4、无意间关掉了移动端模拟，居然好了卧槽!!!（黑人问号脸.gif）继续懵逼…… 5、试着用“选择元素”工具去点选a标签，居然点到了上边一个透明的空标签上（有宽高），试了几次都是如此（嗯？），然后检查发现该标签position: fixed;，移动端页面收缩后挤下来、整好遮挡住了a标签……至此找到原因。 6、因为该标签不需要响应点击事件，所以直接加了句pointer-events:none，问题解决。 【 小结 】 其实最开始应该先试下z-index的（个人有点排斥这个样式，都是自然写法），失策失策~~ 不要随便写fixed的透明标签……血泪教训=_=|||…… 无比怀念FireFox的3D模式……然并卵。以后只好用“选择元素”排除类似的bug了。 pointer-events:none真的是神器，省了很多js（其实是jq）“事件监听+选择器判断/过滤”的事。","categories":[{"name":"经验技巧","slug":"经验技巧","permalink":"https://marsgt.github.io/categories/经验技巧/"},{"name":"前端","slug":"经验技巧/前端","permalink":"https://marsgt.github.io/categories/经验技巧/前端/"}],"tags":[{"name":"随手记","slug":"随手记","permalink":"https://marsgt.github.io/tags/随手记/"},{"name":"HTML","slug":"HTML","permalink":"https://marsgt.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://marsgt.github.io/tags/CSS/"}]},{"title":"前端图片直传OSS试验","slug":"前端图片直传OSS试验","date":"2016-08-31T07:38:27.000Z","updated":"2018-12-30T01:47:10.865Z","comments":true,"path":"2016/08/31/前端图片直传OSS试验/","link":"","permalink":"https://marsgt.github.io/2016/08/31/前端图片直传OSS试验/","excerpt":"前段时间参与了一个H5项目，里边有个需求是用户上传图片。当时的方案是前端先调用微信的JSSDK选择图片并上传，然后再从后端下载到服务器上。然而用的时候发现客户端给的图片有大有小，但是由于用了微信的接口，图片在下载之前是没法控制的。后来在想能不能调用HTML5原生的文件上传接口，另外还可以配合阿里云的OSS对图片做进一步处理，所以就有了这篇文章。","text":"前段时间参与了一个H5项目，里边有个需求是用户上传图片。当时的方案是前端先调用微信的JSSDK选择图片并上传，然后再从后端下载到服务器上。然而用的时候发现客户端给的图片有大有小，但是由于用了微信的接口，图片在下载之前是没法控制的。后来在想能不能调用HTML5原生的文件上传接口，另外还可以配合阿里云的OSS对图片做进一步处理，所以就有了这篇文章。 1. HTML5原生上传 其实之前也有想过用原生的，可手里的项目全是微信平台的H5，原生上传一直被告知有兼容性问题，所以这个方案一直是被搁置的；只是这次觉得用微信接口实在不爽才重新翻出来的，没想到意外发现手里的米4居然可以正常用。。好了闲话不说，上代码： &lt;input id=\"img_input\" type=\"file\" accept=\"image/*\" /> &lt;div id=\"preview_box\">&lt;/div> HTML部分主要就是那个input，至于下边那个div，主要是留着放图片预览用的。 &lt;script src=\"http://cdn.bootcss.com/jquery/2.2.4/jquery.min.js\">&lt;/script> &lt;script> $(\"#img_input\").on(\"change\", function(e) { var file = e.target.files[0]; // 获取图片资源 var fd = new FormData(); // 用formdata上传文件 // 只选择图片文件 if (!file.type.match('image.*')) { return false; } fd.append('file', file, file.name); // 填入文件 $.ajax({ url: 'fileupload.php', data: fd, processData: false, contentType: false, type: 'POST', success: function () { // 成功后显示文件预览 var reader = new FileReader(); reader.readAsDataURL(file); // 读取文件 // 渲染文件 reader.onload = function(ev) { var img = '&lt;img class=\"preview\" src=\"' + ev.target.result + '\" alt=\"preview\"/>'; $(\"#preview_box\").empty().append(img); } } }); }); &lt;/script> 文件填入FormData，然后POST上传，后端（用的PHP）简单写下接收就行。(然后这里顺便想问下如果直接上传blob的话，PHP后端应该怎么写？有大神路过请不吝赐教~小弟这里先谢过了） &lt;?php if ($error == UPLOAD_ERR_OK) { $tmp_name = $_FILES[\"file\"][\"tmp_name\"]; $name = $_FILES[\"file\"][\"name\"]; move_uploaded_file($tmp_name, \"$name\"); } 然后处理下权限啥的，就能跑啦。 2. 前端压缩（localResizeIMG） localResizeIMG 是个好插件，用法也很简单，把 GitHub 里的 dist 文件夹拖下来改个名（我改了个“localRZ”），然后直接引用 lrz.bundle.js 文件就行了： &lt;script src=\"http://cdn.bootcss.com/jquery/2.2.4/jquery.min.js\">&lt;/script> &lt;script src=\"localRZ/lrz.bundle.js\">&lt;/script> &lt;script> $(\"#img_input\").on(\"change\", function(e) { var file = e.target.files[0]; //获取图片资源 var filename = file.name; // 只选择图片文件 if (!file.type.match('image.*')) { return false; } // LocalResizeIMG处理： lrz(file, {width: 400}) .then(function (rst) { $.ajax({ url: 'fileupload.php', data: rst.formData, // LocalResizeIMG 直接封装好的 processData: false, contentType: false, type: 'POST' }).done(function(data, textStatus, jqXHR){ // 图片预览 var img = new Image(); img.src = rst.base64; img.onload = function () { $(\"#preview_box\").empty().append(img); }; }); return rst; }) .catch(function (err) { // 万一出错了，这里可以捕捉到错误信息 // 而且以上的then都不会执行 alert('ERROR:' + err); }) .always(function () { // 不管是成功失败，这里都会执行 }); }); &lt;/script> localResizeIMG 的 文档 写的挺清楚的，哪里不明白的话可以过去看看。 3. 美化上传按钮 原生的文件上传控件略丑，所以一般是要美化一下。HTML： &lt;div class=\"filePicker\"> &lt;input id=\"img_input\" type=\"file\" accept=\"image/*\" /> &lt;label for=\"img_input\">上传图片&lt;/label> &lt;/div> &lt;div class=\"preview_box\">&lt;/div> 放一个 lable 上去，然后隐藏掉原有的 input： &lt;style type=\"text/css\"> .filePicker { margin: 200px; width: 200px; height: 50px; line-height: 50px; text-align: center; color: #fff; background: #00b7ee; } .filePicker label { display: block; width: 100%; height: 100%; } .filePicker input[type=\"file\"] { display: none; } &lt;/style> 这样看起来就舒服多了。 4. 对接OSS 关于直传，阿里官方给了三种方案： 客户端 JavaScript 签名后直传； 客户端申请服务端签名，然后打包上传； 客户端申请服务端签名，打包上传OSS后回调服务端。 这里主要用的是第二种。 根据官方给的案例代码，首先要搞个签名用的PHP： &lt;?php function gmt_iso8601($time) { $dtStr = date(\"c\", $time); $mydatetime = new DateTime($dtStr); $expiration = $mydatetime->format(DateTime::ISO8601); $pos = strpos($expiration, '+'); $expiration = substr($expiration, 0, $pos); return $expiration.\"Z\"; } //自行设置AccessKey和相应Bucket的外网域名 $id= 'xxxxxxxxxxx'; $key= 'yyyyyyyyyy'; $host = 'http://zzzzzzz.oss-cn-xxxxxxxxx.aliyuncs.com/'; $now = time(); $expire = 10; //设置该policy超时时间是10s. 即这个policy过了这个有效时间，将不能访问 $end = $now + $expire; $expiration = gmt_iso8601($end); //文件大小范围.用户可以自己设置 $condition = array(0=>'content-length-range', 1=>0, 2=>1048576000); //设置用户上传指定的前缀 $dir = 'test/'; //用户上传数据的位置匹配,这一步不是必须项,只是为了安全起见,防止用户通过policy上传到别人的目录 $start = array(0=>'starts-with', 1=>'$key', 2=>$dir); //设置bucket $bucket = array(0=>'eq', 1=>'$bucket', 2=>'gmei'); $conditions = array(0=>$bucket, 1=>$condition, 2=>$start); $arr = array('expiration'=>$expiration,'conditions'=>$conditions); //echo json_encode($arr); //return; $policy = json_encode($arr); $base64_policy = base64_encode($policy); $signature = base64_encode(hash_hmac('sha1', $base64_policy, $key, true)); $response = array( 'accessid' => $id, 'host' => $host, 'policy' => $base64_policy, 'signature' => $signature, 'expire' => $end, 'dir' => $dir.'${filename}' ); echo json_encode($response); 里边的东西填一下，然后保存在同目录下就行。然后改下HTML： &lt;script src=\"http://cdn.bootcss.com/jquery/2.2.4/jquery.min.js\">&lt;/script> &lt;script src=\"localRZ/lrz.bundle.js\">&lt;/script> &lt;script> $(\"#img_input\").on(\"change\", function(e) { var file = e.target.files[0]; //获取图片资源 var filename = file.name; // 只选择图片文件 if (!file.type.match('image.*')) { return false; } // LocalResizeIMG写法： lrz(file, {width: 200, fieldName: 'osstest'}) .then(function (rst) { // OSS要求把上传文件放到最后一项，但是用LocalResizeIMG输出的FormData，就只能放在 // 第一项，所以这里要自己new个出来 var ossData = new FormData(); // 先请求授权，然后回调 $.getJSON('ossget.php', function (json) { //签名用的PHP // 添加签名信息 ossData.append('OSSAccessKeyId', json.accessid); ossData.append('policy', json.policy); ossData.append('Signature', json.signature); ossData.append('key', json.dir); // 添加文件 ossData.append('file', rst.file, filename); $.ajax({ url: json.host, data: ossData, processData: false, contentType: false, type: 'POST' }).done(function(){ // 成功后显示图片预览 var img = new Image(); img.src = rst.base64; img.onload = function () { $(\".preview_box\").empty().append(img); }; }); }); return rst; }) .catch(function (err) { // 万一出错了，这里可以捕捉到错误信息 // 而且以上的then都不会执行 alert('ERROR:' + err); }) .always(function () { // 不管是成功失败，这里都会执行 }); }); &lt;/script> 5. 遗留问题 OSS返回给客户端的XML没法正常解析 返回的XML是报错内容，但是不影响文件的正常上传（文件上传返回的是默认的204）。报错内容是（大意）“[AccessDenied]：The bucket you visit is not belong to you.”，查了下文档说原因是“子用户没有Bucket管理的权限(如getBucketAcl CreateBucket、deleteBucket setBucketReferer、 getBucketReferer等)”，调了半天的 RAM（访问控制）也没弄好，不知道是什么原因~ 6. 2016/8/31 补遗： 上次留下几个问题，已经解决了，所以过来填坑。 其实这两个问题算是一个问题，在 PostObject 文档里，表单域里有个参数“success_action_status”，描述是“未指定success_action_redirect表单域时，该表单域指定了上传成功后返回给客户端的状态码。 接受值为200, 201, 204（默认）。 如果该域的值为200或者204，OSS返回一个空文档和相应的状态码。 如果该域的值设置为201，OSS返回一个XML文件和201状态码。 如果其值未设置或者设置成一个非法值，OSS返回一个空文档和204状态码。”所以，之前返回不正常的这个问题，只要强行指定返回201状态码，就可以正常收到返回的XML了（并且也没有先前报错的问题了）。 上代码： &lt;script src=\"http://cdn.bootcss.com/jquery/2.2.4/jquery.min.js\">&lt;/script> &lt;script src=\"localRZ/lrz.bundle.js\">&lt;/script> &lt;script> $(\"#img_input\").on(\"change\", function(e) { var file = e.target.files[0]; //获取图片资源 var filename = file.name; // 只选择图片文件 if (!file.type.match('image.*')) { return false; } // LocalResizeIMG写法： lrz(file, {width: 200, fieldName: 'osstest'}) .then(function (rst) { var ossData = new FormData(); // 先请求授权，然后回调 $.getJSON('ossget.php', function (json) { // 添加配置参数 ossData.append('OSSAccessKeyId', json.accessid); ossData.append('policy', json.policy); ossData.append('Signature', json.signature); ossData.append('key', json.dir); ossData.append('success_action_status', 201); // 指定返回的状态码 ossData.append('file', rst.file, filename); $.ajax({ url: json.host, data: ossData, dataType: 'xml', // 这里加个对返回内容的类型指定 processData: false, contentType: false, type: 'POST' }).done(function(data){ // 返回的上传信息 if ($(data).find('PostResponse')) { var res = $(data).find('PostResponse'); console.info('Bucket：' + res.find('Bucket').text() ); console.info('Location：' + res.find('Location').text() ); console.info('Key：' + res.find('Key').text() ); console.info('ETag：' + res.find('ETag').text() ); } // 图片预览 var img = new Image(); img.src = rst.base64; img.onload = function () { $(\".preview_box\").empty().append(img); }; }); }); return rst; }) .catch(function (err) { // 万一出错了，这里可以捕捉到错误信息 // 而且以上的then都不会执行 alert('ERROR:'+err); }) .always(function () { // 不管是成功失败，这里都会执行 }); }); &lt;/script> 最后总结了下，HTTP 一定要学好啊！！（于是哭着滚去看书了……） 【参考资料】 jQuery手册 - AJAX函数 理解DOMString、Document、FormData、Blob、File、ArrayBuffer数据类型 对象存储OSS - Web端直传实践：采用服务端签名后直传 对象存储OSS - API手册 - Post Object 对象存储OSS - API手册 - PostObject错误及排查 对象存储OSS - OSS控制台客户端Windows版","categories":[{"name":"经验技巧","slug":"经验技巧","permalink":"https://marsgt.github.io/categories/经验技巧/"},{"name":"前端","slug":"经验技巧/前端","permalink":"https://marsgt.github.io/categories/经验技巧/前端/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://marsgt.github.io/tags/PHP/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://marsgt.github.io/tags/JavaScript/"},{"name":"阿里云","slug":"阿里云","permalink":"https://marsgt.github.io/tags/阿里云/"},{"name":"OSS","slug":"OSS","permalink":"https://marsgt.github.io/tags/OSS/"}]},{"title":"brackets插件推荐","slug":"brackets插件推荐","date":"2016-01-10T11:10:37.000Z","updated":"2018-12-30T01:54:25.279Z","comments":true,"path":"2016/01/10/brackets插件推荐/","link":"","permalink":"https://marsgt.github.io/2016/01/10/brackets插件推荐/","excerpt":"一开始用 Brackets 的时候，看了很多推荐插件的文章，里边的插件大抵都差不多，千篇一律，毫无新意。后来偶然碰到了这个网站：Brackets Extensions （里边是各种插件的排行榜，点开之后还有原版介绍，感兴趣的可以挨个试试）后来，我就疯狂的试用了一堆插件……","text":"一开始用 Brackets 的时候，看了很多推荐插件的文章，里边的插件大抵都差不多，千篇一律，毫无新意。后来偶然碰到了这个网站：Brackets Extensions （里边是各种插件的排行榜，点开之后还有原版介绍，感兴趣的可以挨个试试）后来，我就疯狂的试用了一堆插件…… 嗯，下边还是书归正传，还是说一说我自己用的顺手的几个插件吧： Emmet也叫/曾经被称为 ZenCoding ，万年不变的“榜首/必装”插件。不过如果平常没有这个习惯的，也可以试试换用各种 snipper 插件，这些插件的优点就是本身的可定制程度要比 Emmet 高一些（Emmet 反正我自己的程度也就是改改 lang 的设定啊什么的，还得去翻代码。。） Tabs - Custom Working从前边网站上知道的一个插件。没办法，个人对浏览器上的多标签页简直是爱不释手，所以发现了这个插件以后简直是欲罢不能啊~更何况它标签上的 icon 也是挺好看的。。。 Extensions Rating插件管理器的“美化”插件，会增加一些 GitHub 上的头像啊 stars 数啊 forks 数啊什么的东西，方便选择。看各人喜好装吧。 Brackets File Tree Exclude左边文件列表的排除插件，可以指定一些比如像是 git 啊 node_modules 啊之类的不想让它出现的东东。 Js-Beautify &amp; JS CSS Minifier前者负责美化、后者负责压缩，都是我觉得比较好用的。 JSHint &amp; JSHint Configurator文档检查插件，我觉得比自带的 JSLint 要好用。后边那个是在文档中自定义语法规则的。在这里多说一句，屏蔽自带的 JSLint 是在 brackets.json 里边加上 \"language\": { \"javascript\": { \"linting.prefer\": [\"JSHint\"], \"linting.usePreferredOnly\": true } }, 这一句，然后保存重启 Brackets 就行了。 AutoprefixerPostCSS 的神器，专门用来给 CSS 加各种前缀的。 反正常用的就是这些了，还有哪些好用的欢迎推荐~~","categories":[{"name":"经验技巧","slug":"经验技巧","permalink":"https://marsgt.github.io/categories/经验技巧/"},{"name":"开发工具","slug":"经验技巧/开发工具","permalink":"https://marsgt.github.io/categories/经验技巧/开发工具/"}],"tags":[{"name":"brackets","slug":"brackets","permalink":"https://marsgt.github.io/tags/brackets/"},{"name":"编辑器","slug":"编辑器","permalink":"https://marsgt.github.io/tags/编辑器/"},{"name":"插件","slug":"插件","permalink":"https://marsgt.github.io/tags/插件/"}]}]}